var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { COORDINATE_SYSTEM, LIFECYCLE } from './constants';
import AttributeManager from './attribute-manager';
import Stats from './stats';
import { count } from '../utils/count';
import log from '../utils/log';
import { createProps } from '../lifecycle/create-props';
import { diffProps as _diffProps } from '../lifecycle/props';
import { removeLayerInSeer } from './seer-integration';
import { GL, withParameters } from 'luma.gl';
import assert from 'assert';

var LOG_PRIORITY_UPDATE = 1;
var EMPTY_PROPS = Object.freeze({});
var noop = function noop() {};

var defaultProps = {
  // data: Special handling for null, see below
  dataComparator: null,
  updateTriggers: {}, // Update triggers: a core change detection mechanism in deck.gl
  numInstances: undefined,

  visible: true,
  pickable: false,
  opacity: 0.8,

  onHover: noop,
  onClick: noop,

  coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
  coordinateOrigin: [0, 0, 0],

  parameters: {},
  uniforms: {},
  framebuffer: null,

  animation: null, // Passed prop animation functions to evaluate props

  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: function getPolygonOffset(_ref) {
    var layerIndex = _ref.layerIndex;
    return [0, -layerIndex * 100];
  },

  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: [0, 0, 128, 128]
};

var counter = 0;

var Layer = function () {
  // constructor(...propObjects)
  function Layer() {
    _classCallCheck(this, Layer);

    // Merges incoming props with defaults and freezes them.
    // TODO switch to spread operator once we no longer transpile this code
    // this.props = createProps.apply(propObjects);
    /* eslint-disable prefer-spread */
    this.props = createProps.apply(this, arguments);
    /* eslint-enable prefer-spread */

    // Define all members before layer is sealed
    this.id = this.props.id; // The layer's id, used for matching with layers from last render cycle
    this.oldProps = EMPTY_PROPS; // Props from last render used for change detection
    this.count = counter++; // Keep track of how many layer instances you are generating
    this.lifecycle = LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers
    this.state = null; // Will be set to the shared layer state object during layer matching
    this.context = null; // Will reference layer manager's context, contains state shared by layers
    this.parentLayer = null; // reference to the composite layer parent that rendered this layer

    // CompositeLayer members, need to be defined here because of the `Object.seal`
    this.internalState = null;

    // Seal the layer
    Object.seal(this);
  }

  // clone this layer with modified props


  _createClass(Layer, [{
    key: 'clone',
    value: function clone(newProps) {
      return new this.constructor(Object.assign({}, this.props, newProps));
    }
  }, {
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className + '({id: \'' + this.props.id + '\'})';
    }
  }, {
    key: 'setState',


    // Public API

    // Updates selected state members and marks the object for redraw
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }

    // Sets the redraw flag for this layer, will trigger a redraw next animation frame

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // Checks state of attributes and model

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
          clearRedrawFlags = _ref2$clearRedrawFlag === undefined ? false : _ref2$clearRedrawFlag;

      return this._getNeedsRedraw(clearRedrawFlags);
    }

    // Return an array of models used by this layer, can be overriden by layer subclass

  }, {
    key: 'getModels',
    value: function getModels() {
      return this.state.models || (this.state.model ? [this.state.model] : []);
    }
  }, {
    key: 'needsUpdate',
    value: function needsUpdate() {
      // Call subclass lifecycle method
      return this.shouldUpdateState(this._getUpdateParams());
      // End lifecycle method
    }

    // Returns true if the layer is pickable and visible.

  }, {
    key: 'isPickable',
    value: function isPickable() {
      return this.props.pickable && this.props.visible;
    }
  }, {
    key: 'getAttributeManager',
    value: function getAttributeManager() {
      return this.state && this.state.attributeManager;
    }

    // Use iteration (the only required capability on data) to get first element
    // deprecated

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }

    // TODO - needs to refer to context

  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      log.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion');
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      assert((i + 1 >> 24 & 255) === 0, 'index out of picking color range');
      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      assert(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }

    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: 'initializeState',
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          oldContext = _ref3.oldContext,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;

      return changeFlags.propsOrDataChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref4) {
      var oldProps = _ref4.oldProps,
          props = _ref4.props,
          oldContext = _ref4.oldContext,
          context = _ref4.context,
          changeFlags = _ref4.changeFlags;

      var attributeManager = this.getAttributeManager();
      if (changeFlags.dataChanged && attributeManager) {
        attributeManager.invalidateAll();
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // Update attribute transition

  }, {
    key: 'updateTransition',
    value: function updateTransition() {
      var _state = this.state,
          model = _state.model,
          attributeManager = _state.attributeManager;

      var isInTransition = attributeManager && attributeManager.updateTransition();

      if (model && isInTransition) {
        model.setAttributes(attributeManager.getChangedAttributes({ transition: true }));
      }
    }

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(opts) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.getModels()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var model = _step2.value;

          model.draw(opts);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref5) {
      var info = _ref5.info,
          mode = _ref5.mode;
      var index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Default implementation of attribute invalidation, can be redefined

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }

      if (name === 'all') {
        log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
        attributeManager.invalidateAll();
      } else {
        log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + name + ': ' + diffReason);
        attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }

      // Figure out data length
      var numInstances = this.getNumInstances(props);

      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        transitions: props.transitions,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      // TODO - Use getModels?
      var model = this.state.model;

      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref6) {
      var numInstances = _ref6.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return count(data);
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: '_initialize',
    value: function _initialize() {
      assert(arguments.length === 0);
      assert(this.context.gl);
      assert(!this.state);

      var attributeManager = new AttributeManager(this.context.gl, {
        id: this.props.id
      });

      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slightly slows down non instanced layers
      attributeManager.addInstanced({
        instancePickingColors: {
          type: GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      this.internalState = {
        subLayers: null, // reference to sublayers rendered in a previous cycle
        stats: new Stats({ id: 'draw' })
        // animatedProps: null, // Computing animated props requires layer manager state
        // TODO - move these fields here (risks breaking layers)
        // attributeManager,
        // needsRedraw: true,
      };

      this.state = {
        attributeManager: attributeManager,
        model: null,
        needsRedraw: true
      };

      // Call subclass lifecycle methods
      this.initializeState(this.context);
      // End subclass lifecycle methods

      // initializeState callback tends to clear state
      this.setChangeFlags({ dataChanged: true, propsChanged: true, viewportChanged: true });

      this._updateState(this._getUpdateParams());

      if (this.isComposite) {
        this._renderLayers(true);
      }

      var model = this.state.model;

      if (model) {
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }

      // Last but not least, update any sublayers
      if (this.isComposite) {
        this._renderLayers();
      }

      this.clearChangeFlags();
    }

    // Called by layer manager
    // if this layer is new (not matched with an existing layer) oldProps will be empty object

  }, {
    key: '_update',
    value: function _update() {
      assert(arguments.length === 0);

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.needsUpdate();
      // End lifecycle method

      var updateParams = {
        props: this.props,
        oldProps: this.oldProps,
        context: this.context,
        oldContext: this.oldContext,
        changeFlags: this.internalState.changeFlags
      };

      if (stateNeedsUpdate) {
        this._updateState(updateParams);
      }

      // Render or update previously rendered sublayers
      if (this.isComposite) {
        this._renderLayers(stateNeedsUpdate);
      }

      this.clearChangeFlags();
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateState',
    value: function _updateState(updateParams) {
      // Call subclass lifecycle methods
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();
      this._updateModuleSettings();

      // Note: Automatic instance count update only works for single layers
      if (this.state.model) {
        this.state.model.setInstanceCount(this.getNumInstances());
      }
    }

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: '_finalize',
    value: function _finalize() {
      assert(arguments.length === 0);
      // Call subclass lifecycle method
      this.finalizeState(this.context);
      // End lifecycle method
      removeLayerInSeer(this.id);
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref7) {
      var _this = this;

      var _ref7$moduleParameter = _ref7.moduleParameters,
          moduleParameters = _ref7$moduleParameter === undefined ? null : _ref7$moduleParameter,
          _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms,
          _ref7$parameters = _ref7.parameters,
          parameters = _ref7$parameters === undefined ? {} : _ref7$parameters;

      if (!uniforms.picking_uActive) {
        this.updateTransition();
      }

      // TODO/ib - hack move to luma Model.draw
      if (moduleParameters) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var model = _step3.value;

            model.updateModuleSettings(moduleParameters);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      // Apply polygon offset to avoid z-fighting
      // TODO - move to draw-layers
      var getPolygonOffset = this.props.getPolygonOffset;

      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      parameters.polygonOffset = offsets;

      // Call subclass lifecycle method
      withParameters(this.context.gl, parameters, function () {
        _this.draw({ moduleParameters: moduleParameters, uniforms: uniforms, parameters: parameters, context: _this.context });
      });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }

    // Helper methods

  }, {
    key: 'getChangeFlags',
    value: function getChangeFlags() {
      return this.internalState.changeFlags;
    }

    // Dirty some change flags, will be handled by updateLayer
    /* eslint-disable complexity */

  }, {
    key: 'setChangeFlags',
    value: function setChangeFlags(flags) {
      var _this2 = this;

      this.internalState.changeFlags = this.internalState.changeFlags || {};
      var changeFlags = this.internalState.changeFlags;

      // Update primary flags
      if (flags.dataChanged && !changeFlags.dataChanged) {
        changeFlags.dataChanged = flags.dataChanged;
        log.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'dataChanged: ' + flags.dataChanged + ' in ' + _this2.id;
        });
      }
      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {
        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;
        log.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'updateTriggersChanged: ' + (Object.keys(flags.updateTriggersChanged).join(', ') + ' in ' + _this2.id);
        });
      }
      if (flags.propsChanged && !changeFlags.propsChanged) {
        changeFlags.propsChanged = flags.propsChanged;
        log.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'propsChanged: ' + flags.propsChanged + ' in ' + _this2.id;
        });
      }
      if (flags.viewportChanged && !changeFlags.viewportChanged) {
        changeFlags.viewportChanged = flags.viewportChanged;
        log.log(LOG_PRIORITY_UPDATE + 2, function () {
          return 'viewportChanged: ' + flags.viewportChanged + ' in ' + _this2.id;
        });
      }

      // Update composite flags
      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged;
      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;
      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged;
    }
    /* eslint-enable complexity */

    // Clear all changeFlags, typically after an update

  }, {
    key: 'clearChangeFlags',
    value: function clearChangeFlags() {
      this.internalState.changeFlags = {
        // Primary changeFlags, can be strings stating reason for change
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,

        // Derived changeFlags
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
  }, {
    key: 'printChangeFlags',
    value: function printChangeFlags() {
      var flags = this.internalState.changeFlags;
      return '' + (flags.dataChanged ? 'data ' : '') + (flags.propsChanged ? 'props ' : '') + (flags.updateTriggersChanged ? 'triggers ' : '') + (flags.viewportChanged ? 'viewport' : '');
    }

    // Compares the layers props with old props from a matched older layer
    // and extracts change flags that describe what has change so that state
    // can be update correctly with minimal effort
    // TODO - arguments for testing only

  }, {
    key: 'diffProps',
    value: function diffProps() {
      var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.oldProps;

      var changeFlags = _diffProps(newProps, oldProps);

      // iterate over changedTriggers
      if (changeFlags.updateTriggersChanged) {
        for (var key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this._activeUpdateTrigger(key);
          }
        }
      }

      return this.setChangeFlags(changeFlags);
    }

    // PRIVATE METHODS

  }, {
    key: '_getUpdateParams',
    value: function _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.oldProps,
        context: this.context,
        oldContext: this.oldContext || {},
        changeFlags: this.internalState.changeFlags
      };
    }

    // Checks state of attributes and model

  }, {
    key: '_getNeedsRedraw',
    value: function _getNeedsRedraw(clearRedrawFlags) {
      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw && this.id;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      // TODO - is attribute manager needed? - Model should be enough.
      var attributeManager = this.getAttributeManager();
      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || attributeManagerNeedsRedraw;

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var model = _step4.value;

          var modelNeedsRedraw = model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
          if (modelNeedsRedraw && typeof modelNeedsRedraw !== 'string') {
            modelNeedsRedraw = 'model ' + model.id;
          }
          redraw = redraw || modelNeedsRedraw;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return redraw;
    }

    // Called by layer manager to transfer state from an old layer

  }, {
    key: '_transferState',
    value: function _transferState(oldLayer) {
      var state = oldLayer.state,
          internalState = oldLayer.internalState,
          props = oldLayer.props;

      assert(state && internalState);

      // Move state
      state.layer = this;
      this.state = state;
      this.internalState = internalState;
      // Note: We keep the state ref on old layers to support async actions
      // oldLayer.state = null;

      // Keep a temporary ref to the old props, for prop comparison
      this.oldProps = props;

      // Update model layer reference
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var model = _step5.value;

          model.userData.layer = this;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this.diffProps();
    }

    // Operate on each changed triggers, will be called when an updateTrigger changes

  }, {
    key: '_activeUpdateTrigger',
    value: function _activeUpdateTrigger(propName) {
      this.invalidateAttribute(propName);
    }

    //  Helper to check that required props are supplied

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      var uniforms = {
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      };
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var model = _step6.value;

          model.setUniforms(uniforms);
        }

        // TODO - set needsRedraw on the model(s)?
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      this.state.needsRedraw = true;
    }
  }, {
    key: '_updateModuleSettings',
    value: function _updateModuleSettings() {
      var settings = {
        pickingHighlightColor: this.props.highlightColor
      };
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var model = _step7.value;

          model.updateModuleSettings(settings);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.getModels()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var model = _step8.value;

          model.setUniforms(uniformMap);
        }

        // TODO - set needsRedraw on the model(s)?
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      this.state.needsRedraw = true;
      log.deprecated('layer.setUniforms', 'model.setUniforms');
    }
  }, {
    key: 'stats',
    get: function get() {
      return this.internalState.stats;
    }
  }]);

  return Layer;
}();

export default Layer;


Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9sYXllci5qcyJdLCJuYW1lcyI6WyJDT09SRElOQVRFX1NZU1RFTSIsIkxJRkVDWUNMRSIsIkF0dHJpYnV0ZU1hbmFnZXIiLCJTdGF0cyIsImNvdW50IiwibG9nIiwiY3JlYXRlUHJvcHMiLCJkaWZmUHJvcHMiLCJyZW1vdmVMYXllckluU2VlciIsIkdMIiwid2l0aFBhcmFtZXRlcnMiLCJhc3NlcnQiLCJMT0dfUFJJT1JJVFlfVVBEQVRFIiwiRU1QVFlfUFJPUFMiLCJPYmplY3QiLCJmcmVlemUiLCJub29wIiwiZGVmYXVsdFByb3BzIiwiZGF0YUNvbXBhcmF0b3IiLCJ1cGRhdGVUcmlnZ2VycyIsIm51bUluc3RhbmNlcyIsInVuZGVmaW5lZCIsInZpc2libGUiLCJwaWNrYWJsZSIsIm9wYWNpdHkiLCJvbkhvdmVyIiwib25DbGljayIsImNvb3JkaW5hdGVTeXN0ZW0iLCJMTkdMQVQiLCJjb29yZGluYXRlT3JpZ2luIiwicGFyYW1ldGVycyIsInVuaWZvcm1zIiwiZnJhbWVidWZmZXIiLCJhbmltYXRpb24iLCJnZXRQb2x5Z29uT2Zmc2V0IiwibGF5ZXJJbmRleCIsImhpZ2hsaWdodGVkT2JqZWN0SW5kZXgiLCJhdXRvSGlnaGxpZ2h0IiwiaGlnaGxpZ2h0Q29sb3IiLCJjb3VudGVyIiwiTGF5ZXIiLCJwcm9wcyIsImFwcGx5IiwiYXJndW1lbnRzIiwiaWQiLCJvbGRQcm9wcyIsImxpZmVjeWNsZSIsIk5PX1NUQVRFIiwic3RhdGUiLCJjb250ZXh0IiwicGFyZW50TGF5ZXIiLCJpbnRlcm5hbFN0YXRlIiwic2VhbCIsIm5ld1Byb3BzIiwiY29uc3RydWN0b3IiLCJhc3NpZ24iLCJjbGFzc05hbWUiLCJsYXllck5hbWUiLCJuYW1lIiwidXBkYXRlT2JqZWN0IiwibmVlZHNSZWRyYXciLCJyZWRyYXciLCJjbGVhclJlZHJhd0ZsYWdzIiwiX2dldE5lZWRzUmVkcmF3IiwibW9kZWxzIiwibW9kZWwiLCJzaG91bGRVcGRhdGVTdGF0ZSIsIl9nZXRVcGRhdGVQYXJhbXMiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiZGF0YSIsIm9iamVjdCIsImxuZ0xhdCIsInZpZXdwb3J0IiwiQXJyYXkiLCJpc0FycmF5IiwicHJvamVjdCIsInh5IiwidW5wcm9qZWN0IiwicHJvamVjdEZsYXQiLCJ1bnByb2plY3RGbGF0Iiwic2NyZWVuUGl4ZWxzIiwiZGVwcmVjYXRlZCIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJpIiwiY29sb3IiLCJVaW50OEFycmF5IiwiaTEiLCJpMiIsImkzIiwiaW5kZXgiLCJFcnJvciIsIm9sZENvbnRleHQiLCJjaGFuZ2VGbGFncyIsInByb3BzT3JEYXRhQ2hhbmdlZCIsImdldEF0dHJpYnV0ZU1hbmFnZXIiLCJkYXRhQ2hhbmdlZCIsImludmFsaWRhdGVBbGwiLCJpc0luVHJhbnNpdGlvbiIsInVwZGF0ZVRyYW5zaXRpb24iLCJzZXRBdHRyaWJ1dGVzIiwiZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMiLCJ0cmFuc2l0aW9uIiwib3B0cyIsImdldE1vZGVscyIsImRyYXciLCJpbmZvIiwibW9kZSIsImRpZmZSZWFzb24iLCJpbnZhbGlkYXRlIiwiZ2V0TnVtSW5zdGFuY2VzIiwidXBkYXRlIiwidHJhbnNpdGlvbnMiLCJidWZmZXJzIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImNsZWFyQ2hhbmdlZEZsYWdzIiwiYXR0cmlidXRlIiwidmFsdWUiLCJzaXplIiwicGlja2luZ0NvbG9yIiwiZW5jb2RlUGlja2luZ0NvbG9yIiwibGVuZ3RoIiwiZ2wiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBpY2tpbmdDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyIsInN1YkxheWVycyIsInN0YXRzIiwiaW5pdGlhbGl6ZVN0YXRlIiwic2V0Q2hhbmdlRmxhZ3MiLCJwcm9wc0NoYW5nZWQiLCJ2aWV3cG9ydENoYW5nZWQiLCJfdXBkYXRlU3RhdGUiLCJpc0NvbXBvc2l0ZSIsIl9yZW5kZXJMYXllcnMiLCJwcm9ncmFtIiwiZ2VvbWV0cnkiLCJnZXRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VGbGFncyIsInN0YXRlTmVlZHNVcGRhdGUiLCJuZWVkc1VwZGF0ZSIsInVwZGF0ZVBhcmFtcyIsInVwZGF0ZVN0YXRlIiwidXBkYXRlQXR0cmlidXRlcyIsIl91cGRhdGVCYXNlVW5pZm9ybXMiLCJfdXBkYXRlTW9kdWxlU2V0dGluZ3MiLCJzZXRJbnN0YW5jZUNvdW50IiwiZmluYWxpemVTdGF0ZSIsIm1vZHVsZVBhcmFtZXRlcnMiLCJwaWNraW5nX3VBY3RpdmUiLCJ1cGRhdGVNb2R1bGVTZXR0aW5ncyIsIm9mZnNldHMiLCJwb2x5Z29uT2Zmc2V0IiwiZ2V0UGlja2luZ0luZm8iLCJmbGFncyIsInVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCIsImtleXMiLCJqb2luIiwic29tZXRoaW5nQ2hhbmdlZCIsImtleSIsIl9hY3RpdmVVcGRhdGVUcmlnZ2VyIiwiYXR0cmlidXRlTWFuYWdlck5lZWRzUmVkcmF3IiwiZ2V0TmVlZHNSZWRyYXciLCJtb2RlbE5lZWRzUmVkcmF3Iiwib2xkTGF5ZXIiLCJsYXllciIsInVzZXJEYXRhIiwicHJvcE5hbWUiLCJpbnZhbGlkYXRlQXR0cmlidXRlIiwicHJvcGVydHlOYW1lIiwiY29uZGl0aW9uIiwiTWF0aCIsInBvdyIsIk9ORSIsInNldFVuaWZvcm1zIiwic2V0dGluZ3MiLCJwaWNraW5nSGlnaGxpZ2h0Q29sb3IiLCJ1bmlmb3JtTWFwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVFBLGlCQUFSLEVBQTJCQyxTQUEzQixRQUEyQyxhQUEzQztBQUNBLE9BQU9DLGdCQUFQLE1BQTZCLHFCQUE3QjtBQUNBLE9BQU9D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bnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU0sIExJRkVDWUNMRX0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IEF0dHJpYnV0ZU1hbmFnZXIgZnJvbSAnLi9hdHRyaWJ1dGUtbWFuYWdlcic7XG5pbXBvcnQgU3RhdHMgZnJvbSAnLi9zdGF0cyc7XG5pbXBvcnQge2NvdW50fSBmcm9tICcuLi91dGlscy9jb3VudCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL3V0aWxzL2xvZyc7XG5pbXBvcnQge2NyZWF0ZVByb3BzfSBmcm9tICcuLi9saWZlY3ljbGUvY3JlYXRlLXByb3BzJztcbmltcG9ydCB7ZGlmZlByb3BzfSBmcm9tICcuLi9saWZlY3ljbGUvcHJvcHMnO1xuaW1wb3J0IHtyZW1vdmVMYXllckluU2Vlcn0gZnJvbSAnLi9zZWVyLWludGVncmF0aW9uJztcbmltcG9ydCB7R0wsIHdpdGhQYXJhbWV0ZXJzfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgTE9HX1BSSU9SSVRZX1VQREFURSA9IDE7XG5jb25zdCBFTVBUWV9QUk9QUyA9IE9iamVjdC5mcmVlemUoe30pO1xuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIC8vIGRhdGE6IFNwZWNpYWwgaGFuZGxpbmcgZm9yIG51bGwsIHNlZSBiZWxvd1xuICBkYXRhQ29tcGFyYXRvcjogbnVsbCxcbiAgdXBkYXRlVHJpZ2dlcnM6IHt9LCAvLyBVcGRhdGUgdHJpZ2dlcnM6IGEgY29yZSBjaGFuZ2UgZGV0ZWN0aW9uIG1lY2hhbmlzbSBpbiBkZWNrLmdsXG4gIG51bUluc3RhbmNlczogdW5kZWZpbmVkLFxuXG4gIHZpc2libGU6IHRydWUsXG4gIHBpY2thYmxlOiBmYWxzZSxcbiAgb3BhY2l0eTogMC44LFxuXG4gIG9uSG92ZXI6IG5vb3AsXG4gIG9uQ2xpY2s6IG5vb3AsXG5cbiAgY29vcmRpbmF0ZVN5c3RlbTogQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBjb29yZGluYXRlT3JpZ2luOiBbMCwgMCwgMF0sXG5cbiAgcGFyYW1ldGVyczoge30sXG4gIHVuaWZvcm1zOiB7fSxcbiAgZnJhbWVidWZmZXI6IG51bGwsXG5cbiAgYW5pbWF0aW9uOiBudWxsLCAvLyBQYXNzZWQgcHJvcCBhbmltYXRpb24gZnVuY3Rpb25zIHRvIGV2YWx1YXRlIHByb3BzXG5cbiAgLy8gT2Zmc2V0IGRlcHRoIGJhc2VkIG9uIGxheWVyIGluZGV4IHRvIGF2b2lkIHotZmlnaHRpbmcuXG4gIC8vIE5lZ2F0aXZlIHZhbHVlcyBwdWxsIGxheWVyIHRvd2FyZHMgdGhlIGNhbWVyYVxuICAvLyBodHRwczovL3d3dy5vcGVuZ2wub3JnL2FyY2hpdmVzL3Jlc291cmNlcy9mYXEvdGVjaG5pY2FsL3BvbHlnb25vZmZzZXQuaHRtXG4gIGdldFBvbHlnb25PZmZzZXQ6ICh7bGF5ZXJJbmRleH0pID0+IFswLCAtbGF5ZXJJbmRleCAqIDEwMF0sXG5cbiAgLy8gU2VsZWN0aW9uL0hpZ2hsaWdodGluZ1xuICBoaWdobGlnaHRlZE9iamVjdEluZGV4OiBudWxsLFxuICBhdXRvSGlnaGxpZ2h0OiBmYWxzZSxcbiAgaGlnaGxpZ2h0Q29sb3I6IFswLCAwLCAxMjgsIDEyOF1cbn07XG5cbmxldCBjb3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICAvLyBjb25zdHJ1Y3RvciguLi5wcm9wT2JqZWN0cylcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gTWVyZ2VzIGluY29taW5nIHByb3BzIHdpdGggZGVmYXVsdHMgYW5kIGZyZWV6ZXMgdGhlbS5cbiAgICAvLyBUT0RPIHN3aXRjaCB0byBzcHJlYWQgb3BlcmF0b3Igb25jZSB3ZSBubyBsb25nZXIgdHJhbnNwaWxlIHRoaXMgY29kZVxuICAgIC8vIHRoaXMucHJvcHMgPSBjcmVhdGVQcm9wcy5hcHBseShwcm9wT2JqZWN0cyk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXNwcmVhZCAqL1xuICAgIHRoaXMucHJvcHMgPSBjcmVhdGVQcm9wcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8qIGVzbGludC1lbmFibGUgcHJlZmVyLXNwcmVhZCAqL1xuXG4gICAgLy8gRGVmaW5lIGFsbCBtZW1iZXJzIGJlZm9yZSBsYXllciBpcyBzZWFsZWRcbiAgICB0aGlzLmlkID0gdGhpcy5wcm9wcy5pZDsgLy8gVGhlIGxheWVyJ3MgaWQsIHVzZWQgZm9yIG1hdGNoaW5nIHdpdGggbGF5ZXJzIGZyb20gbGFzdCByZW5kZXIgY3ljbGVcbiAgICB0aGlzLm9sZFByb3BzID0gRU1QVFlfUFJPUFM7IC8vIFByb3BzIGZyb20gbGFzdCByZW5kZXIgdXNlZCBmb3IgY2hhbmdlIGRldGVjdGlvblxuICAgIHRoaXMuY291bnQgPSBjb3VudGVyKys7IC8vIEtlZXAgdHJhY2sgb2YgaG93IG1hbnkgbGF5ZXIgaW5zdGFuY2VzIHlvdSBhcmUgZ2VuZXJhdGluZ1xuICAgIHRoaXMubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk5PX1NUQVRFOyAvLyBIZWxwcyB0cmFjayBhbmQgZGVidWcgdGhlIGxpZmUgY3ljbGUgb2YgdGhlIGxheWVyc1xuICAgIHRoaXMuc3RhdGUgPSBudWxsOyAvLyBXaWxsIGJlIHNldCB0byB0aGUgc2hhcmVkIGxheWVyIHN0YXRlIG9iamVjdCBkdXJpbmcgbGF5ZXIgbWF0Y2hpbmdcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsOyAvLyBXaWxsIHJlZmVyZW5jZSBsYXllciBtYW5hZ2VyJ3MgY29udGV4dCwgY29udGFpbnMgc3RhdGUgc2hhcmVkIGJ5IGxheWVyc1xuICAgIHRoaXMucGFyZW50TGF5ZXIgPSBudWxsOyAvLyByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2l0ZSBsYXllciBwYXJlbnQgdGhhdCByZW5kZXJlZCB0aGlzIGxheWVyXG5cbiAgICAvLyBDb21wb3NpdGVMYXllciBtZW1iZXJzLCBuZWVkIHRvIGJlIGRlZmluZWQgaGVyZSBiZWNhdXNlIG9mIHRoZSBgT2JqZWN0LnNlYWxgXG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gbnVsbDtcblxuICAgIC8vIFNlYWwgdGhlIGxheWVyXG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICAvLyBjbG9uZSB0aGlzIGxheWVyIHdpdGggbW9kaWZpZWQgcHJvcHNcbiAgY2xvbmUobmV3UHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgbmV3UHJvcHMpKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubGF5ZXJOYW1lIHx8IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gYCR7Y2xhc3NOYW1lfSh7aWQ6ICcke3RoaXMucHJvcHMuaWR9J30pYDtcbiAgfVxuXG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0YXRlLnN0YXRzO1xuICB9XG5cbiAgLy8gUHVibGljIEFQSVxuXG4gIC8vIFVwZGF0ZXMgc2VsZWN0ZWQgc3RhdGUgbWVtYmVycyBhbmQgbWFya3MgdGhlIG9iamVjdCBmb3IgcmVkcmF3XG4gIHNldFN0YXRlKHVwZGF0ZU9iamVjdCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwgdXBkYXRlT2JqZWN0KTtcbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFNldHMgdGhlIHJlZHJhdyBmbGFnIGZvciB0aGlzIGxheWVyLCB3aWxsIHRyaWdnZXIgYSByZWRyYXcgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gcmVkcmF3O1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrcyBzdGF0ZSBvZiBhdHRyaWJ1dGVzIGFuZCBtb2RlbFxuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE5lZWRzUmVkcmF3KGNsZWFyUmVkcmF3RmxhZ3MpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIG1vZGVscyB1c2VkIGJ5IHRoaXMgbGF5ZXIsIGNhbiBiZSBvdmVycmlkZW4gYnkgbGF5ZXIgc3ViY2xhc3NcbiAgZ2V0TW9kZWxzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm1vZGVscyB8fCAodGhpcy5zdGF0ZS5tb2RlbCA/IFt0aGlzLnN0YXRlLm1vZGVsXSA6IFtdKTtcbiAgfVxuXG4gIG5lZWRzVXBkYXRlKCkge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHJldHVybiB0aGlzLnNob3VsZFVwZGF0ZVN0YXRlKHRoaXMuX2dldFVwZGF0ZVBhcmFtcygpKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBsYXllciBpcyBwaWNrYWJsZSBhbmQgdmlzaWJsZS5cbiAgaXNQaWNrYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5waWNrYWJsZSAmJiB0aGlzLnByb3BzLnZpc2libGU7XG4gIH1cblxuICBnZXRBdHRyaWJ1dGVNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlcjtcbiAgfVxuXG4gIC8vIFVzZSBpdGVyYXRpb24gKHRoZSBvbmx5IHJlcXVpcmVkIGNhcGFiaWxpdHkgb24gZGF0YSkgdG8gZ2V0IGZpcnN0IGVsZW1lbnRcbiAgLy8gZGVwcmVjYXRlZFxuICBnZXRGaXJzdE9iamVjdCgpIHtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnByb3BzO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gUFJPSkVDVElPTiBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGEgcG9pbnQgd2l0aCBjdXJyZW50IG1hcCBzdGF0ZSAobGF0LCBsb24sIHpvb20sIHBpdGNoLCBiZWFyaW5nKVxuICAgKlxuICAgKiBOb3RlOiBQb3NpdGlvbiBjb252ZXJzaW9uIGlzIGRvbmUgaW4gc2hhZGVyLCBzbyBpbiBtYW55IGNhc2VzIHRoZXJlIGlzIG5vIG5lZWRcbiAgICogZm9yIHRoaXMgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBsbmdMYXQgLSBsb25nIGFuZCBsYXQgdmFsdWVzXG4gICAqIEByZXR1cm4ge0FycmF5fFR5cGVkQXJyYXl9IC0geCwgeSBjb29yZGluYXRlc1xuICAgKi9cbiAgcHJvamVjdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3QoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3QoeHkpO1xuICB9XG5cbiAgcHJvamVjdEZsYXQobG5nTGF0KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShsbmdMYXQpLCAnTGF5ZXIucHJvamVjdCBuZWVkcyBbbG5nLGxhdF0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdEZsYXQobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdEZsYXQoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3RGbGF0KHh5KTtcbiAgfVxuXG4gIC8vIFRPRE8gLSBuZWVkcyB0byByZWZlciB0byBjb250ZXh0XG4gIHNjcmVlblRvRGV2aWNlUGl4ZWxzKHNjcmVlblBpeGVscykge1xuICAgIGxvZy5kZXByZWNhdGVkKCdzY3JlZW5Ub0RldmljZVBpeGVscycsICdEZWNrR0wgcHJvcCB1c2VEZXZpY2VQaXhlbHMgZm9yIGNvbnZlcnNpb24nKTtcbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gICAgcmV0dXJuIHNjcmVlblBpeGVscyAqIGRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBhIGJsYWNrIGNvbG9yXG4gICAqL1xuICBudWxsUGlja2luZ0NvbG9yKCkge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge2ludH0gaSAtIGluZGV4IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgY29sb3JcbiAgICovXG4gIGVuY29kZVBpY2tpbmdDb2xvcihpKSB7XG4gICAgYXNzZXJ0KCgoKGkgKyAxKSA+PiAyNCkgJiAyNTUpID09PSAwLCAnaW5kZXggb3V0IG9mIHBpY2tpbmcgY29sb3IgcmFuZ2UnKTtcbiAgICByZXR1cm4gWyhpICsgMSkgJiAyNTUsICgoaSArIDEpID4+IDgpICYgMjU1LCAoKChpICsgMSkgPj4gOCkgPj4gOCkgJiAyNTVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBjb2xvciAtIGNvbG9yIGFycmF5IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgcGlja2luZyBjb2xvclxuICAgKi9cbiAgZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgYXNzZXJ0KGNvbG9yIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgY29uc3QgW2kxLCBpMiwgaTNdID0gY29sb3I7XG4gICAgLy8gMSB3YXMgYWRkZWQgdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBjb25zdCBpbmRleCA9IGkxICsgaTIgKiAyNTYgKyBpMyAqIDY1NTM2IC0gMTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBMSUZFQ1lDTEUgTUVUSE9EUywgb3ZlcnJpZGRlbiBieSB0aGUgbGF5ZXIgc3ViY2xhc3Nlc1xuXG4gIC8vIENhbGxlZCBvbmNlIHRvIHNldCB1cCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAvLyBBcHAgY2FuIGNyZWF0ZSBXZWJHTCByZXNvdXJjZXNcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgJHt0aGlzfSBoYXMgbm90IGRlZmluZWQgaW5pdGlhbGl6ZVN0YXRlYCk7XG4gIH1cblxuICAvLyBMZXQncyBsYXllciBjb250cm9sIGlmIHVwZGF0ZVN0YXRlIHNob3VsZCBiZSBjYWxsZWRcbiAgc2hvdWxkVXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgcmV0dXJuIGNoYW5nZUZsYWdzLnByb3BzT3JEYXRhQ2hhbmdlZDtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24sIGFsbCBhdHRyaWJ1dGVzIHdpbGwgYmUgaW52YWxpZGF0ZWQgYW5kIHVwZGF0ZWRcbiAgLy8gd2hlbiBkYXRhIGNoYW5nZXNcbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCAmJiBhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb25jZSB3aGVuIGxheWVyIGlzIG5vIGxvbmdlciBtYXRjaGVkIGFuZCBzdGF0ZSB3aWxsIGJlIGRpc2NhcmRlZFxuICAvLyBBcHAgY2FuIGRlc3Ryb3kgV2ViR0wgcmVzb3VyY2VzIGhlcmVcbiAgZmluYWxpemVTdGF0ZSgpIHt9XG5cbiAgLy8gVXBkYXRlIGF0dHJpYnV0ZSB0cmFuc2l0aW9uXG4gIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gICAgY29uc3Qge21vZGVsLCBhdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaXNJblRyYW5zaXRpb24gPSBhdHRyaWJ1dGVNYW5hZ2VyICYmIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlVHJhbnNpdGlvbigpO1xuXG4gICAgaWYgKG1vZGVsICYmIGlzSW5UcmFuc2l0aW9uKSB7XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZU1hbmFnZXIuZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe3RyYW5zaXRpb246IHRydWV9KSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgc3RhdGUgaGFzIGEgbW9kZWwsIGRyYXcgaXQgd2l0aCBzdXBwbGllZCB1bmlmb3Jtc1xuICBkcmF3KG9wdHMpIHtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLmRyYXcob3B0cyk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsbGVkIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlclxuICAvLyBAcmV0dXJuIG51bGwgdG8gY2FuY2VsIGV2ZW50XG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvLCBtb2RlfSkge1xuICAgIGNvbnN0IHtpbmRleH0gPSBpbmZvO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIC8vIElmIHByb3BzLmRhdGEgaXMgYW4gaW5kZXhhYmxlIGFycmF5LCBnZXQgdGhlIG9iamVjdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5kYXRhKSkge1xuICAgICAgICBpbmZvLm9iamVjdCA9IHRoaXMucHJvcHMuZGF0YVtpbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICAvLyBFTkQgTElGRUNZQ0xFIE1FVEhPRFNcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGF0dHJpYnV0ZSBpbnZhbGlkYXRpb24sIGNhbiBiZSByZWRlZmluZWRcbiAgaW52YWxpZGF0ZUF0dHJpYnV0ZShuYW1lID0gJ2FsbCcsIGRpZmZSZWFzb24gPSAnJykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBpZiAoIWF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSwgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhbGwgYXR0cmlidXRlczogJHtkaWZmUmVhc29ufWApO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSwgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhdHRyaWJ1dGUgJHtuYW1lfTogJHtkaWZmUmVhc29ufWApO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxzIGF0dHJpYnV0ZSBtYW5hZ2VyIHRvIHVwZGF0ZSBhbnkgV2ViR0wgYXR0cmlidXRlcywgY2FuIGJlIHJlZGVmaW5lZFxuICB1cGRhdGVBdHRyaWJ1dGVzKHByb3BzKSB7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGlmICghYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgZGF0YSBsZW5ndGhcbiAgICBjb25zdCBudW1JbnN0YW5jZXMgPSB0aGlzLmdldE51bUluc3RhbmNlcyhwcm9wcyk7XG5cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLnVwZGF0ZSh7XG4gICAgICBkYXRhOiBwcm9wcy5kYXRhLFxuICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgcHJvcHMsXG4gICAgICB0cmFuc2l0aW9uczogcHJvcHMudHJhbnNpdGlvbnMsXG4gICAgICBidWZmZXJzOiBwcm9wcyxcbiAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAvLyBEb24ndCB3b3JyeSBhYm91dCBub24tYXR0cmlidXRlIHByb3BzXG4gICAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLy8gVE9ETyAtIFVzZSBnZXRNb2RlbHM/XG4gICAgY29uc3Qge21vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe2NsZWFyQ2hhbmdlZEZsYWdzOiB0cnVlfSk7XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKGNoYW5nZWRBdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlLCB7bnVtSW5zdGFuY2VzfSkge1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgLy8gYWRkIDEgdG8gaW5kZXggdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrKSB7XG4gICAgICBjb25zdCBwaWNraW5nQ29sb3IgPSB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpKTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMF0gPSBwaWNraW5nQ29sb3JbMF07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gcGlja2luZ0NvbG9yWzFdO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAyXSA9IHBpY2tpbmdDb2xvclsyXTtcbiAgICB9XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLy8gRGVkdWNlcyBudW1lciBvZiBpbnN0YW5jZXMuIEludGVudGlvbiBpcyB0byBzdXBwb3J0OlxuICAvLyAtIEV4cGxpY2l0IHNldHRpbmcgb2YgbnVtSW5zdGFuY2VzXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgc2l6ZSBtZW1iZXJcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiBmb3IgQ2xhc3NpYyBBcnJheXMgdmlhIHRoZSBidWlsdC1pbiBsZW5ndGggYXR0cmlidXRlXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gdmlhIGFycmF5c1xuICBnZXROdW1JbnN0YW5jZXMocHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgbGF5ZXIgaGFzIHNldCBpdHMgb3duIHZhbHVlXG4gICAgaWYgKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFwcCBoYXMgcHJvdmlkZWQgYW4gZXhwbGljaXQgdmFsdWVcbiAgICBpZiAocHJvcHMubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5udW1JbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgLy8gVXNlIGNvbnRhaW5lciBsaWJyYXJ5IHRvIGdldCBhIGNvdW50IGZvciBhbnkgRVM2IGNvbnRhaW5lciBvciBvYmplY3RcbiAgICBjb25zdCB7ZGF0YX0gPSBwcm9wcztcbiAgICByZXR1cm4gY291bnQoZGF0YSk7XG4gIH1cblxuICAvLyBMQVlFUiBNQU5BR0VSIEFQSVxuICAvLyBTaG91bGQgb25seSBiZSBjYWxsZWQgYnkgdGhlIGRlY2suZ2wgTGF5ZXJNYW5hZ2VyIGNsYXNzXG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgd2hlbiBhIG5ldyBsYXllciBpcyBmb3VuZFxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICBhc3NlcnQoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCk7XG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC5nbCk7XG4gICAgYXNzZXJ0KCF0aGlzLnN0YXRlKTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSBuZXcgQXR0cmlidXRlTWFuYWdlcih0aGlzLmNvbnRleHQuZ2wsIHtcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkXG4gICAgfSk7XG5cbiAgICAvLyBBbGwgaW5zdGFuY2VkIGxheWVycyBnZXQgaW5zdGFuY2VQaWNraW5nQ29sb3JzIGF0dHJpYnV0ZSBieSBkZWZhdWx0XG4gICAgLy8gVGhlaXIgc2hhZGVycyBjYW4gdXNlIGl0IHRvIHJlbmRlciBhIHBpY2tpbmcgc2NlbmVcbiAgICAvLyBUT0RPIC0gdGhpcyBzbGlnaHRseSBzbG93cyBkb3duIG5vbiBpbnN0YW5jZWQgbGF5ZXJzXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHtcbiAgICAgIHN1YkxheWVyczogbnVsbCwgLy8gcmVmZXJlbmNlIHRvIHN1YmxheWVycyByZW5kZXJlZCBpbiBhIHByZXZpb3VzIGN5Y2xlXG4gICAgICBzdGF0czogbmV3IFN0YXRzKHtpZDogJ2RyYXcnfSlcbiAgICAgIC8vIGFuaW1hdGVkUHJvcHM6IG51bGwsIC8vIENvbXB1dGluZyBhbmltYXRlZCBwcm9wcyByZXF1aXJlcyBsYXllciBtYW5hZ2VyIHN0YXRlXG4gICAgICAvLyBUT0RPIC0gbW92ZSB0aGVzZSBmaWVsZHMgaGVyZSAocmlza3MgYnJlYWtpbmcgbGF5ZXJzKVxuICAgICAgLy8gYXR0cmlidXRlTWFuYWdlcixcbiAgICAgIC8vIG5lZWRzUmVkcmF3OiB0cnVlLFxuICAgIH07XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYXR0cmlidXRlTWFuYWdlcixcbiAgICAgIG1vZGVsOiBudWxsLFxuICAgICAgbmVlZHNSZWRyYXc6IHRydWVcbiAgICB9O1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKHRoaXMuY29udGV4dCk7XG4gICAgLy8gRW5kIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG5cbiAgICAvLyBpbml0aWFsaXplU3RhdGUgY2FsbGJhY2sgdGVuZHMgdG8gY2xlYXIgc3RhdGVcbiAgICB0aGlzLnNldENoYW5nZUZsYWdzKHtkYXRhQ2hhbmdlZDogdHJ1ZSwgcHJvcHNDaGFuZ2VkOiB0cnVlLCB2aWV3cG9ydENoYW5nZWQ6IHRydWV9KTtcblxuICAgIHRoaXMuX3VwZGF0ZVN0YXRlKHRoaXMuX2dldFVwZGF0ZVBhcmFtcygpKTtcblxuICAgIGlmICh0aGlzLmlzQ29tcG9zaXRlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJMYXllcnModHJ1ZSk7XG4gICAgfVxuXG4gICAgY29uc3Qge21vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5pZCA9IHRoaXMucHJvcHMuaWQ7XG4gICAgICBtb2RlbC5wcm9ncmFtLmlkID0gYCR7dGhpcy5wcm9wcy5pZH0tcHJvZ3JhbWA7XG4gICAgICBtb2RlbC5nZW9tZXRyeS5pZCA9IGAke3RoaXMucHJvcHMuaWR9LWdlb21ldHJ5YDtcbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlTWFuYWdlci5nZXRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cblxuICAgIC8vIExhc3QgYnV0IG5vdCBsZWFzdCwgdXBkYXRlIGFueSBzdWJsYXllcnNcbiAgICBpZiAodGhpcy5pc0NvbXBvc2l0ZSkge1xuICAgICAgdGhpcy5fcmVuZGVyTGF5ZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhckNoYW5nZUZsYWdzKCk7XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlclxuICAvLyBpZiB0aGlzIGxheWVyIGlzIG5ldyAobm90IG1hdGNoZWQgd2l0aCBhbiBleGlzdGluZyBsYXllcikgb2xkUHJvcHMgd2lsbCBiZSBlbXB0eSBvYmplY3RcbiAgX3VwZGF0ZSgpIHtcbiAgICBhc3NlcnQoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCk7XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICBjb25zdCBzdGF0ZU5lZWRzVXBkYXRlID0gdGhpcy5uZWVkc1VwZGF0ZSgpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICBjb25zdCB1cGRhdGVQYXJhbXMgPSB7XG4gICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIG9sZFByb3BzOiB0aGlzLm9sZFByb3BzLFxuICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgY2hhbmdlRmxhZ3M6IHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFnc1xuICAgIH07XG5cbiAgICBpZiAoc3RhdGVOZWVkc1VwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgb3IgdXBkYXRlIHByZXZpb3VzbHkgcmVuZGVyZWQgc3VibGF5ZXJzXG4gICAgaWYgKHRoaXMuaXNDb21wb3NpdGUpIHtcbiAgICAgIHRoaXMuX3JlbmRlckxheWVycyhzdGF0ZU5lZWRzVXBkYXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyQ2hhbmdlRmxhZ3MoKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX3VwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcykge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgLy8gRW5kIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG5cbiAgICAvLyBBZGQgYW55IHN1YmNsYXNzIGF0dHJpYnV0ZXNcbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXModGhpcy5wcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlQmFzZVVuaWZvcm1zKCk7XG4gICAgdGhpcy5fdXBkYXRlTW9kdWxlU2V0dGluZ3MoKTtcblxuICAgIC8vIE5vdGU6IEF1dG9tYXRpYyBpbnN0YW5jZSBjb3VudCB1cGRhdGUgb25seSB3b3JrcyBmb3Igc2luZ2xlIGxheWVyc1xuICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IG1hbmFnZXIgd2hlbiBsYXllciBpcyBhYm91dCB0byBiZSBkaXNwb3NlZFxuICAvLyBOb3RlOiBub3QgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgb24gYXBwbGljYXRpb24gc2h1dGRvd25cbiAgX2ZpbmFsaXplKCkge1xuICAgIGFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSAwKTtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB0aGlzLmZpbmFsaXplU3RhdGUodGhpcy5jb250ZXh0KTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHJlbW92ZUxheWVySW5TZWVyKHRoaXMuaWQpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyB1bmlmb3Jtc1xuICBkcmF3TGF5ZXIoe21vZHVsZVBhcmFtZXRlcnMgPSBudWxsLCB1bmlmb3JtcyA9IHt9LCBwYXJhbWV0ZXJzID0ge319KSB7XG4gICAgaWYgKCF1bmlmb3Jtcy5waWNraW5nX3VBY3RpdmUpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH1cblxuICAgIC8vIFRPRE8vaWIgLSBoYWNrIG1vdmUgdG8gbHVtYSBNb2RlbC5kcmF3XG4gICAgaWYgKG1vZHVsZVBhcmFtZXRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5nZXRNb2RlbHMoKSkge1xuICAgICAgICBtb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyhtb2R1bGVQYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBwb2x5Z29uIG9mZnNldCB0byBhdm9pZCB6LWZpZ2h0aW5nXG4gICAgLy8gVE9ETyAtIG1vdmUgdG8gZHJhdy1sYXllcnNcbiAgICBjb25zdCB7Z2V0UG9seWdvbk9mZnNldH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG9mZnNldHMgPSAoZ2V0UG9seWdvbk9mZnNldCAmJiBnZXRQb2x5Z29uT2Zmc2V0KHVuaWZvcm1zKSkgfHwgWzAsIDBdO1xuICAgIHBhcmFtZXRlcnMucG9seWdvbk9mZnNldCA9IG9mZnNldHM7XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB3aXRoUGFyYW1ldGVycyh0aGlzLmNvbnRleHQuZ2wsIHBhcmFtZXRlcnMsICgpID0+IHtcbiAgICAgIHRoaXMuZHJhdyh7bW9kdWxlUGFyYW1ldGVycywgdW5pZm9ybXMsIHBhcmFtZXRlcnMsIGNvbnRleHQ6IHRoaXMuY29udGV4dH0pO1xuICAgIH0pO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICAvLyB7dW5pZm9ybXMgPSB7fSwgLi4ub3B0c31cbiAgcGlja0xheWVyKG9wdHMpIHtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICByZXR1cm4gdGhpcy5nZXRQaWNraW5nSW5mbyhvcHRzKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZHNcbiAgZ2V0Q2hhbmdlRmxhZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFncztcbiAgfVxuXG4gIC8vIERpcnR5IHNvbWUgY2hhbmdlIGZsYWdzLCB3aWxsIGJlIGhhbmRsZWQgYnkgdXBkYXRlTGF5ZXJcbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuICBzZXRDaGFuZ2VGbGFncyhmbGFncykge1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFncyA9IHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFncyB8fCB7fTtcbiAgICBjb25zdCBjaGFuZ2VGbGFncyA9IHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFncztcblxuICAgIC8vIFVwZGF0ZSBwcmltYXJ5IGZsYWdzXG4gICAgaWYgKGZsYWdzLmRhdGFDaGFuZ2VkICYmICFjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgPSBmbGFncy5kYXRhQ2hhbmdlZDtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSArIDEsICgpID0+IGBkYXRhQ2hhbmdlZDogJHtmbGFncy5kYXRhQ2hhbmdlZH0gaW4gJHt0aGlzLmlkfWApO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkICYmICFjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQpIHtcbiAgICAgIGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCA9XG4gICAgICAgIGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCAmJiBmbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWRcbiAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oe30sIGZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkKVxuICAgICAgICAgIDogZmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIHx8IGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZDtcbiAgICAgIGxvZy5sb2coXG4gICAgICAgIExPR19QUklPUklUWV9VUERBVEUgKyAxLFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICd1cGRhdGVUcmlnZ2Vyc0NoYW5nZWQ6ICcgK1xuICAgICAgICAgIGAke09iamVjdC5rZXlzKGZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCkuam9pbignLCAnKX0gaW4gJHt0aGlzLmlkfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmbGFncy5wcm9wc0NoYW5nZWQgJiYgIWNoYW5nZUZsYWdzLnByb3BzQ2hhbmdlZCkge1xuICAgICAgY2hhbmdlRmxhZ3MucHJvcHNDaGFuZ2VkID0gZmxhZ3MucHJvcHNDaGFuZ2VkO1xuICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfVVBEQVRFICsgMSwgKCkgPT4gYHByb3BzQ2hhbmdlZDogJHtmbGFncy5wcm9wc0NoYW5nZWR9IGluICR7dGhpcy5pZH1gKTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLnZpZXdwb3J0Q2hhbmdlZCAmJiAhY2hhbmdlRmxhZ3Mudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICBjaGFuZ2VGbGFncy52aWV3cG9ydENoYW5nZWQgPSBmbGFncy52aWV3cG9ydENoYW5nZWQ7XG4gICAgICBsb2cubG9nKFxuICAgICAgICBMT0dfUFJJT1JJVFlfVVBEQVRFICsgMixcbiAgICAgICAgKCkgPT4gYHZpZXdwb3J0Q2hhbmdlZDogJHtmbGFncy52aWV3cG9ydENoYW5nZWR9IGluICR7dGhpcy5pZH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjb21wb3NpdGUgZmxhZ3NcbiAgICBjb25zdCBwcm9wc09yRGF0YUNoYW5nZWQgPVxuICAgICAgZmxhZ3MuZGF0YUNoYW5nZWQgfHwgZmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIHx8IGZsYWdzLnByb3BzQ2hhbmdlZDtcbiAgICBjaGFuZ2VGbGFncy5wcm9wc09yRGF0YUNoYW5nZWQgPSBjaGFuZ2VGbGFncy5wcm9wc09yRGF0YUNoYW5nZWQgfHwgcHJvcHNPckRhdGFDaGFuZ2VkO1xuICAgIGNoYW5nZUZsYWdzLnNvbWV0aGluZ0NoYW5nZWQgPVxuICAgICAgY2hhbmdlRmxhZ3Muc29tZXRoaW5nQ2hhbmdlZCB8fCBwcm9wc09yRGF0YUNoYW5nZWQgfHwgZmxhZ3Mudmlld3BvcnRDaGFuZ2VkO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIC8vIENsZWFyIGFsbCBjaGFuZ2VGbGFncywgdHlwaWNhbGx5IGFmdGVyIGFuIHVwZGF0ZVxuICBjbGVhckNoYW5nZUZsYWdzKCkge1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFncyA9IHtcbiAgICAgIC8vIFByaW1hcnkgY2hhbmdlRmxhZ3MsIGNhbiBiZSBzdHJpbmdzIHN0YXRpbmcgcmVhc29uIGZvciBjaGFuZ2VcbiAgICAgIGRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgIHByb3BzQ2hhbmdlZDogZmFsc2UsXG4gICAgICB1cGRhdGVUcmlnZ2Vyc0NoYW5nZWQ6IGZhbHNlLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkOiBmYWxzZSxcblxuICAgICAgLy8gRGVyaXZlZCBjaGFuZ2VGbGFnc1xuICAgICAgcHJvcHNPckRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgIHNvbWV0aGluZ0NoYW5nZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHByaW50Q2hhbmdlRmxhZ3MoKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLmludGVybmFsU3RhdGUuY2hhbmdlRmxhZ3M7XG4gICAgcmV0dXJuIGBcXFxuJHtmbGFncy5kYXRhQ2hhbmdlZCA/ICdkYXRhICcgOiAnJ31cXFxuJHtmbGFncy5wcm9wc0NoYW5nZWQgPyAncHJvcHMgJyA6ICcnfVxcXG4ke2ZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCA/ICd0cmlnZ2VycyAnIDogJyd9XFxcbiR7ZmxhZ3Mudmlld3BvcnRDaGFuZ2VkID8gJ3ZpZXdwb3J0JyA6ICcnfVxcXG5gO1xuICB9XG5cbiAgLy8gQ29tcGFyZXMgdGhlIGxheWVycyBwcm9wcyB3aXRoIG9sZCBwcm9wcyBmcm9tIGEgbWF0Y2hlZCBvbGRlciBsYXllclxuICAvLyBhbmQgZXh0cmFjdHMgY2hhbmdlIGZsYWdzIHRoYXQgZGVzY3JpYmUgd2hhdCBoYXMgY2hhbmdlIHNvIHRoYXQgc3RhdGVcbiAgLy8gY2FuIGJlIHVwZGF0ZSBjb3JyZWN0bHkgd2l0aCBtaW5pbWFsIGVmZm9ydFxuICAvLyBUT0RPIC0gYXJndW1lbnRzIGZvciB0ZXN0aW5nIG9ubHlcbiAgZGlmZlByb3BzKG5ld1Byb3BzID0gdGhpcy5wcm9wcywgb2xkUHJvcHMgPSB0aGlzLm9sZFByb3BzKSB7XG4gICAgY29uc3QgY2hhbmdlRmxhZ3MgPSBkaWZmUHJvcHMobmV3UHJvcHMsIG9sZFByb3BzKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBjaGFuZ2VkVHJpZ2dlcnNcbiAgICBpZiAoY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQpIHtcbiAgICAgICAgaWYgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZFtrZXldKSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZlVXBkYXRlVHJpZ2dlcihrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0Q2hhbmdlRmxhZ3MoY2hhbmdlRmxhZ3MpO1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgX2dldFVwZGF0ZVBhcmFtcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICBvbGRQcm9wczogdGhpcy5vbGRQcm9wcyxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCB8fCB7fSxcbiAgICAgIGNoYW5nZUZsYWdzOiB0aGlzLmludGVybmFsU3RhdGUuY2hhbmdlRmxhZ3NcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2hlY2tzIHN0YXRlIG9mIGF0dHJpYnV0ZXMgYW5kIG1vZGVsXG4gIF9nZXROZWVkc1JlZHJhdyhjbGVhclJlZHJhd0ZsYWdzKSB7XG4gICAgLy8gdGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBieSB0aGUgcmVuZGVyIGxvb3AgYXMgc29vbiBhIHRoZSBsYXllclxuICAgIC8vIGhhcyBiZWVuIGNyZWF0ZWQsIHNvIGd1YXJkIGFnYWluc3QgdW5pbml0aWFsaXplZCBzdGF0ZVxuICAgIGlmICghdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgKHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgJiYgdGhpcy5pZCk7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG5cbiAgICAvLyBUT0RPIC0gaXMgYXR0cmlidXRlIG1hbmFnZXIgbmVlZGVkPyAtIE1vZGVsIHNob3VsZCBiZSBlbm91Z2guXG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXJOZWVkc1JlZHJhdyA9XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyICYmIGF0dHJpYnV0ZU1hbmFnZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgYXR0cmlidXRlTWFuYWdlck5lZWRzUmVkcmF3O1xuXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICBsZXQgbW9kZWxOZWVkc1JlZHJhdyA9IG1vZGVsLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSk7XG4gICAgICBpZiAobW9kZWxOZWVkc1JlZHJhdyAmJiB0eXBlb2YgbW9kZWxOZWVkc1JlZHJhdyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbW9kZWxOZWVkc1JlZHJhdyA9IGBtb2RlbCAke21vZGVsLmlkfWA7XG4gICAgICB9XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbW9kZWxOZWVkc1JlZHJhdztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgdG8gdHJhbnNmZXIgc3RhdGUgZnJvbSBhbiBvbGQgbGF5ZXJcbiAgX3RyYW5zZmVyU3RhdGUob2xkTGF5ZXIpIHtcbiAgICBjb25zdCB7c3RhdGUsIGludGVybmFsU3RhdGUsIHByb3BzfSA9IG9sZExheWVyO1xuICAgIGFzc2VydChzdGF0ZSAmJiBpbnRlcm5hbFN0YXRlKTtcblxuICAgIC8vIE1vdmUgc3RhdGVcbiAgICBzdGF0ZS5sYXllciA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGU7XG4gICAgLy8gTm90ZTogV2Uga2VlcCB0aGUgc3RhdGUgcmVmIG9uIG9sZCBsYXllcnMgdG8gc3VwcG9ydCBhc3luYyBhY3Rpb25zXG4gICAgLy8gb2xkTGF5ZXIuc3RhdGUgPSBudWxsO1xuXG4gICAgLy8gS2VlcCBhIHRlbXBvcmFyeSByZWYgdG8gdGhlIG9sZCBwcm9wcywgZm9yIHByb3AgY29tcGFyaXNvblxuICAgIHRoaXMub2xkUHJvcHMgPSBwcm9wcztcblxuICAgIC8vIFVwZGF0ZSBtb2RlbCBsYXllciByZWZlcmVuY2VcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLnVzZXJEYXRhLmxheWVyID0gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmRpZmZQcm9wcygpO1xuICB9XG5cbiAgLy8gT3BlcmF0ZSBvbiBlYWNoIGNoYW5nZWQgdHJpZ2dlcnMsIHdpbGwgYmUgY2FsbGVkIHdoZW4gYW4gdXBkYXRlVHJpZ2dlciBjaGFuZ2VzXG4gIF9hY3RpdmVVcGRhdGVUcmlnZ2VyKHByb3BOYW1lKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgfVxuXG4gIC8vICBIZWxwZXIgdG8gY2hlY2sgdGhhdCByZXF1aXJlZCBwcm9wcyBhcmUgc3VwcGxpZWRcbiAgX2NoZWNrUmVxdWlyZWRQcm9wKHByb3BlcnR5TmFtZSwgY29uZGl0aW9uKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9IHVuZGVmaW5lZCBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICAgIGlmIChjb25kaXRpb24gJiYgIWNvbmRpdGlvbih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUJhc2VVbmlmb3JtcygpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIC8vIGFwcGx5IGdhbW1hIHRvIG9wYWNpdHkgdG8gbWFrZSBpdCB2aXN1YWxseSBcImxpbmVhclwiXG4gICAgICBvcGFjaXR5OiBNYXRoLnBvdyh0aGlzLnByb3BzLm9wYWNpdHksIDEgLyAyLjIpLFxuICAgICAgT05FOiAxLjBcbiAgICB9O1xuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5nZXRNb2RlbHMoKSkge1xuICAgICAgbW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBzZXQgbmVlZHNSZWRyYXcgb24gdGhlIG1vZGVsKHMpP1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG5cbiAgX3VwZGF0ZU1vZHVsZVNldHRpbmdzKCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgcGlja2luZ0hpZ2hsaWdodENvbG9yOiB0aGlzLnByb3BzLmhpZ2hsaWdodENvbG9yXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLnVwZGF0ZU1vZHVsZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIE1FVEhPRFNcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKSB7XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICBtb2RlbC5zZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gc2V0IG5lZWRzUmVkcmF3IG9uIHRoZSBtb2RlbChzKT9cbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICBsb2cuZGVwcmVjYXRlZCgnbGF5ZXIuc2V0VW5pZm9ybXMnLCAnbW9kZWwuc2V0VW5pZm9ybXMnKTtcbiAgfVxufVxuXG5MYXllci5sYXllck5hbWUgPSAnTGF5ZXInO1xuTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19