{"version":3,"sources":["../../src/webgl-utils/create-canvas.js"],"names":["getPageLoadPromise","createCanvas","getCanvas","getCSSSize","getDrawingBufferSize","calculateDrawingBufferSize","resizeCanvas","resizeDrawingBuffer","isPageLoaded","document","readyState","pageLoadPromise","Promise","resolve","reject","window","onload","width","height","id","insert","canvas","createElement","style","Number","isFinite","then","body","insertBefore","firstChild","Error","getElementById","clientWidth","clientHeight","options","useDevicePixels","deprecated","useDevicePixelRatio","cssToDevicePixels","devicePixelRatio","cssSize","Math","floor","newBufferSize"],"mappings":"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","file":"create-canvas.js","sourcesContent":["// Resizing a webgl canvas\n\n/* global window, document */\nimport {log, isBrowser} from '../utils';\n\nlet isPageLoaded = isBrowser && document.readyState === 'complete';\n\nconst pageLoadPromise = isBrowser ?\n  new Promise((resolve, reject) => {\n    if (isPageLoaded) {\n      resolve(document);\n      return;\n    }\n    window.onload = () => {\n      isPageLoaded = true;\n      resolve(document);\n    };\n  }) :\n  Promise.resolve({});\n\n/**\n * Returns a promise that resolves when the page is loaded\n * at this point the DOM can be manipulated, and e.g. a new canvas can be inserted\n * @return {Promise} - resolves when the page is loaded\n */\nexport function getPageLoadPromise() {\n  return pageLoadPromise;\n}\n\n/**\n * Create a canvas\n * @param {Number} width - set to 100%\n * @param {Number} height - set to 100%\n */\nexport function createCanvas({width = 800, height = 600, id = 'gl-canvas', insert = true}) {\n  const canvas = document.createElement('canvas');\n  canvas.id = id;\n  canvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  canvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  // add the canvas to the body element once the page has loaded\n  if (insert) {\n    getPageLoadPromise().then(document => {\n      const body = document.body;\n      body.insertBefore(canvas, body.firstChild);\n    });\n  }\n  return canvas;\n}\n\n/**\n * Gets an already created canvas from the DOM\n * @param {Number} id - DOM element id\n */\nexport function getCanvas({id}) {\n  if (!isPageLoaded) {\n    throw new Error(`createGLContext called on canvas '${id}' before page was loaded`);\n  }\n  return document.getElementById(id);\n}\n\n// Gets current size of canvas in css (logical/window) coordinates\nexport function getCSSSize(canvas) {\n  return {\n    width: canvas.clientWidth,\n    height: canvas.clientHeight\n  };\n}\n\n// Gets current size of canvas drawing buffer in actual pixels\n// This is needed for the gl.viewport call\nexport function getDrawingBufferSize(canvas) {\n  return {\n    width: canvas.width,\n    height: canvas.height\n  };\n}\n\n// Calculate the drawing buffer size that would cover current canvas size and device pixel ratio\n// Intention is that every pixel in the drawing buffer will have a 1-to-1 mapping with\n// actual device pixels in the hardware framebuffer, allowing us to render at the full\n// resolution of the device.\nexport function calculateDrawingBufferSize(canvas, options) {\n  let {useDevicePixels = true} = options;\n  if ('useDevicePixelRatio' in options) {\n    log.deprecated('useDevicePixelRatio', 'useDevicePixels');\n    useDevicePixels = options.useDevicePixels || options.useDevicePixelRatio;\n  }\n  const cssToDevicePixels = useDevicePixels ? window.devicePixelRatio || 1 : 1;\n\n  // Lookup the size the browser is displaying the canvas in CSS pixels\n  // and compute a size needed to make our drawingbuffer match it in\n  // device pixels.\n  const cssSize = getCSSSize(canvas);\n  return {\n    width: Math.floor(cssSize.width * cssToDevicePixels),\n    height: Math.floor(cssSize.height * cssToDevicePixels),\n    devicePixelRatio: cssToDevicePixels\n  };\n}\n\n/**\n * Resizes canvas in \"CSS coordinates\" (note these can be very different from device coords,\n * depending on devicePixelRatio/retina screens and size of drawing buffer)\n * and can be changed separately from drawing buffer size.\n * Therefore, normally `resizeDrawingBuffer` should be called after calling `resizeCanvas`.\n *\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width, height - new width and height of canvas in CSS coordinates\n */\nexport function resizeCanvas(canvas, {\n  width,\n  height\n}) {\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n}\n\n/**\n * Resize the canvas' drawing buffer to match the canvas CSS size,\n * and by default to also consider devicePixelRatio\n * detects if anything has changed, can be called every frame\n * for best visual results, usually set to either:\n *  canvas CSS width x canvas CSS height\n *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio\n *\n * NOTE: Regardless of size, the drawing buffer will always be scaled to the viewport\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width - new width of canvas in CSS coordinates\n * @param {Number} height - new height of canvas in CSS coordinates\n */\nexport function resizeDrawingBuffer(canvas, {\n  useDevicePixelRatio = null, // deprecated\n  useDevicePixels = true\n}) {\n  // Resize the render buffer of the canvas to match canvas client size\n  if (useDevicePixelRatio !== null) {\n    log.deprecated('useDevicePixelRatio', 'useDevicePixels');\n    useDevicePixels = useDevicePixelRatio;\n  }\n  // multiplying with dpr (Optionally can be turned off)\n  const newBufferSize = calculateDrawingBufferSize(canvas, {useDevicePixels});\n  // Only update if the canvas size has not changed\n  if (newBufferSize.width !== canvas.width || newBufferSize.height !== canvas.height) {\n    // Make the canvas render buffer the same size as\n    canvas.width = newBufferSize.width;\n    canvas.height = newBufferSize.height;\n    // Always reset CSS size after setting drawing buffer size\n    // canvas.style.width = `${cssSize.width}px`;\n    // canvas.style.height = `${cssSize.height}px`;\n  }\n}\n"]}