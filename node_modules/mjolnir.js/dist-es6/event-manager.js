var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { Manager } from './utils/hammer';

import WheelInput from './inputs/wheel-input';
import MoveInput from './inputs/move-input';
import KeyInput from './inputs/key-input';

import { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';

import { whichButtons, getOffsetPosition } from './utils/event-utils';

function preventDefault(evt) {
  evt.preventDefault();
}

// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.

var EventManager = function () {
  function EventManager() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EventManager);

    this.options = options;
    this.eventHandlers = [];

    this._onBasicInput = this._onBasicInput.bind(this);
    this._onOtherEvent = this._onOtherEvent.bind(this);

    this.setElement(element);

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  _createClass(EventManager, [{
    key: 'setElement',
    value: function setElement(element) {
      var _this = this;

      if (this.element) {
        // unregister all events
        this.destroy();
      }
      this.element = element;
      if (!element) {
        return;
      }

      var options = this.options;

      var ManagerClass = options.Manager || Manager;

      this.manager = new ManagerClass(element, { recognizers: options.recognizers || RECOGNIZERS }).on('hammer.input', this._onBasicInput);

      if (!options.recognizers) {
        // Set default recognize withs
        // http://hammerjs.github.io/recognize-with/
        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {
          var recognizer = _this.manager.get(name);
          if (recognizer) {
            RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }

      // Handle events not handled by Hammer.js:
      // - mouse wheel
      // - pointer/touch/mouse move
      this.wheelInput = new WheelInput(element, this._onOtherEvent, { enable: false });
      this.moveInput = new MoveInput(element, this._onOtherEvent, { enable: false });
      this.keyInput = new KeyInput(element, this._onOtherEvent, { enable: false });

      if (options.rightButton) {
        // Block right click
        element.addEventListener('contextmenu', preventDefault);
      }

      // Register all existing events
      this.eventHandlers.forEach(function (_ref) {
        var recognizerName = _ref.recognizerName,
            eventAlias = _ref.eventAlias,
            wrappedHandler = _ref.wrappedHandler;

        // Enable recognizer for this event.
        _this._toggleRecognizer(recognizerName, true);
        _this.manager.on(eventAlias, wrappedHandler);
      });
    }

    // Tear down internal event management implementations.

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.element) {
        this.element.removeEventListener('contextmenu', preventDefault);

        // wheelInput etc. are created in setElement() and therefore
        // cannot exist if there is no element
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.manager.destroy();

        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.manager = null;
        this.element = null;
      }
    }

    // Register an event handler function to be called on `event`.

  }, {
    key: 'on',
    value: function on(event, handler, srcElement) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler, srcElement);
      } else {
        srcElement = handler;
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName], srcElement);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: '_toggleRecognizer',
    value: function _toggleRecognizer(name, enabled) {
      var manager = this.manager;

      if (!manager) {
        return;
      }
      var recognizer = manager.get(name);
      if (recognizer) {
        recognizer.set({ enable: enabled });

        var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
        if (fallbackRecognizers && !this.options.recognizers) {
          // Set default require failures
          // http://hammerjs.github.io/require-failure/
          fallbackRecognizers.forEach(function (otherName) {
            var otherRecognizer = manager.get(otherName);
            if (enabled) {
              // Wait for this recognizer to fail
              otherRecognizer.requireFailure(name);
            } else {
              // Do not wait for this recognizer to fail
              otherRecognizer.dropRequireFailure(name);
            }
          });
        }
      }
      this.wheelInput.enableEventType(name, enabled);
      this.moveInput.enableEventType(name, enabled);
      this.keyInput.enableEventType(name, enabled);
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var manager = this.manager,
          eventHandlers = this.eventHandlers;

      var wrappedHandler = this._wrapEventHandler(event, handler, srcElement);
      // Alias to a recognized gesture as necessary.
      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      // Get recognizer for this event
      var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Enable recognizer for this event.
      this._toggleRecognizer(recognizerName, true);

      // Find ancestors
      var ancestorEventHandlers = eventHandlers.filter(function (entry) {
        return entry.eventAlias === eventAlias && entry.srcElement !== srcElement && (!entry.srcElement || entry.srcElement.contains(srcElement));
      });

      // Save wrapped handler
      eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, srcElement: srcElement,
        handler: handler, wrappedHandler: wrappedHandler });

      // Sort handlers by DOM hierarchy
      // So the event will always fire first on child nodes
      ancestorEventHandlers.forEach(function (entry) {
        return manager.off(eventAlias, entry.wrappedHandler);
      });
      if (manager) {
        manager.on(eventAlias, wrappedHandler);
      }
      ancestorEventHandlers.forEach(function (entry) {
        return manager.on(eventAlias, entry.wrappedHandler);
      });
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      var manager = this.manager,
          eventHandlers = this.eventHandlers;

      var eventHandlerRemoved = false;

      // Find saved handler if any.
      for (var i = eventHandlers.length; i--;) {
        var entry = eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          if (manager) {
            manager.off(entry.eventAlias, entry.wrappedHandler);
          }
          // Delete saved handler
          eventHandlers.splice(i, 1);
          eventHandlerRemoved = true;
        }
      }

      if (eventHandlerRemoved) {
        // Alias to a recognized gesture as necessary.
        var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        // Get recognizer for this event
        var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        // Disable recognizer if no more handlers are attached to its events
        var isRecognizerUsed = eventHandlers.find(function (entry) {
          return entry.recognizerName === recognizerName;
        });
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler, srcElement) {
      var _this2 = this;

      return function (event) {
        var mjolnirEvent = event.mjolnirEvent;


        if (!mjolnirEvent) {
          mjolnirEvent = _this2._normalizeEvent(event);
          event.mjolnirEvent = mjolnirEvent;
        }

        var isStopped = mjolnirEvent.handled && mjolnirEvent.handled !== srcElement;

        if (!isStopped) {
          var isFromDecendant = !srcElement || srcElement.contains(event.srcEvent.target);
          if (isFromDecendant) {
            handler(Object.assign({}, mjolnirEvent, {
              type: type,
              stopPropagation: function stopPropagation() {
                if (!mjolnirEvent.handled) {
                  mjolnirEvent.handled = srcElement;
                }
              }
            }));
          }
        }
      };
    }

    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */

  }, {
    key: '_normalizeEvent',
    value: function _normalizeEvent(event) {
      var element = this.element;


      return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, element), {
        handled: false,
        rootElement: element
      });
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        this.manager.emit(alias, event);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);

  return EventManager;
}();

export default EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ldmVudC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIk1hbmFnZXIiLCJXaGVlbElucHV0IiwiTW92ZUlucHV0IiwiS2V5SW5wdXQiLCJCQVNJQ19FVkVOVF9BTElBU0VTIiwiRVZFTlRfUkVDT0dOSVpFUl9NQVAiLCJHRVNUVVJFX0VWRU5UX0FMSUFTRVMiLCJSRUNPR05JWkVSUyIsIlJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAiLCJSRUNPR05JWkVSX0ZBTExCQUNLX01BUCIsIndoaWNoQnV0dG9ucyIsImdldE9mZnNldFBvc2l0aW9uIiwicHJldmVudERlZmF1bHQiLCJldnQiLCJFdmVudE1hbmFnZXIiLCJlbGVtZW50Iiwib3B0aW9ucyIsImV2ZW50SGFuZGxlcnMiLCJfb25CYXNpY0lucHV0IiwiYmluZCIsIl9vbk90aGVyRXZlbnQiLCJzZXRFbGVtZW50IiwiZXZlbnRzIiwib24iLCJkZXN0cm95IiwiTWFuYWdlckNsYXNzIiwibWFuYWdlciIsInJlY29nbml6ZXJzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJyZWNvZ25pemVyIiwiZ2V0IiwibmFtZSIsInJlY29nbml6ZVdpdGgiLCJvdGhlck5hbWUiLCJ3aGVlbElucHV0IiwiZW5hYmxlIiwibW92ZUlucHV0Iiwia2V5SW5wdXQiLCJyaWdodEJ1dHRvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWNvZ25pemVyTmFtZSIsImV2ZW50QWxpYXMiLCJ3cmFwcGVkSGFuZGxlciIsIl90b2dnbGVSZWNvZ25pemVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiaGFuZGxlciIsInNyY0VsZW1lbnQiLCJfYWRkRXZlbnRIYW5kbGVyIiwiZXZlbnROYW1lIiwiX3JlbW92ZUV2ZW50SGFuZGxlciIsImVuYWJsZWQiLCJzZXQiLCJmYWxsYmFja1JlY29nbml6ZXJzIiwib3RoZXJSZWNvZ25pemVyIiwicmVxdWlyZUZhaWx1cmUiLCJkcm9wUmVxdWlyZUZhaWx1cmUiLCJlbmFibGVFdmVudFR5cGUiLCJfd3JhcEV2ZW50SGFuZGxlciIsImFuY2VzdG9yRXZlbnRIYW5kbGVycyIsImZpbHRlciIsImVudHJ5IiwiY29udGFpbnMiLCJwdXNoIiwib2ZmIiwiZXZlbnRIYW5kbGVyUmVtb3ZlZCIsImkiLCJsZW5ndGgiLCJzcGxpY2UiLCJpc1JlY29nbml6ZXJVc2VkIiwiZmluZCIsInR5cGUiLCJtam9sbmlyRXZlbnQiLCJfbm9ybWFsaXplRXZlbnQiLCJpc1N0b3BwZWQiLCJoYW5kbGVkIiwiaXNGcm9tRGVjZW5kYW50Iiwic3JjRXZlbnQiLCJ0YXJnZXQiLCJhc3NpZ24iLCJzdG9wUHJvcGFnYXRpb24iLCJyb290RWxlbWVudCIsImFsaWFzIiwiZW1pdCJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLE9BQVIsUUFBc0IsZ0JBQXRCOztBQUVBLE9BQU9DLFVBQVAsTUFBdUIsc0JBQXZCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixxQkFBdEI7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLG9CQUFyQjs7QUFFQSxTQUNFQyxtQkFERixFQUVFQyxvQkFGRixFQUdFQyxxQkFIRixFQUlFQyxXQUpGLEVBS0VDLHlCQUxGLEVBTUVDLHVCQU5GLFFBT08sYUFQUDs7QUFTQSxTQUFRQyxZQUFSLEVBQXNCQyxpQkFBdEIsUUFBOEMscUJBQTlDOztBQUVBLFNBQVNDLGNBQVQsQ0FBd0JDLEdBQXhCLEVBQTZCO0FBQzNCQSxNQUFJRCxjQUFKO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0lBQ3FCRSxZO0FBQ25CLDBCQUEwQztBQUFBLFFBQTlCQyxPQUE4Qix1RUFBcEIsSUFBb0I7QUFBQSxRQUFkQyxPQUFjLHVFQUFKLEVBQUk7O0FBQUE7O0FBQ3hDLFNBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLGFBQUwsR0FBcUIs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QmpCLE1BQU1nQyxRQUFOLENBQWVDLE1BQW5DLENBQXZDO0FBQ0EsY0FBSUYsZUFBSixFQUFxQjtBQUNuQjlCLG9CQUFRcEIsT0FBT3FELE1BQVAsQ0FBYyxFQUFkLEVBQWtCUCxZQUFsQixFQUFnQztBQUN0Q0Qsd0JBRHNDO0FBRXRDUywrQkFBaUIsMkJBQU07QUFDckIsb0JBQUksQ0FBQ1IsYUFBYUcsT0FBbEIsRUFBMkI7QUFDekJILCtCQUFhRyxPQUFiLEdBQXVCNUIsVUFBdkI7QUFDRDtBQUNGO0FBTnFDLGFBQWhDLENBQVI7QUFRRDtBQUNGO0FBQ0YsT0F2QkQ7QUF3QkQ7O0FBRUQ7Ozs7OztvQ0FHZ0JGLEssRUFBTztBQUFBLFVBQ2RoQyxPQURjLEdBQ0gsSUFERyxDQUNkQSxPQURjOzs7QUFHckIsYUFBT2EsT0FBT3FELE1BQVAsQ0FBYyxFQUFkLEVBQWtCbEMsS0FBbEIsRUFDTHJDLGFBQWFxQyxLQUFiLENBREssRUFFTHBDLGtCQUFrQm9DLEtBQWxCLEVBQXlCaEMsT0FBekIsQ0FGSyxFQUdMO0FBQ0U4RCxpQkFBUyxLQURYO0FBRUVNLHFCQUFhcEU7QUFGZixPQUhLLENBQVA7QUFPRDs7QUFFRDs7Ozs7Ozs7OztrQ0FPY2dDLEssRUFBTztBQUFBLFVBQ1pnQyxRQURZLEdBQ0FoQyxLQURBLENBQ1pnQyxRQURZOztBQUVuQixVQUFNSyxRQUFRaEYsb0JBQW9CMkUsU0FBU04sSUFBN0IsQ0FBZDtBQUNBLFVBQUlXLEtBQUosRUFBVztBQUNUO0FBQ0EsYUFBSzFELE9BQUwsQ0FBYTJELElBQWIsQ0FBa0JELEtBQWxCLEVBQXlCckMsS0FBekI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O2tDQUljQSxLLEVBQU87QUFDbkIsV0FBS3JCLE9BQUwsQ0FBYTJELElBQWIsQ0FBa0J0QyxNQUFNMEIsSUFBeEIsRUFBOEIxQixLQUE5QjtBQUNEOzs7Ozs7ZUE3UmtCakMsWSIsImZpbGUiOiJldmVudC1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtNYW5hZ2VyfSBmcm9tICcuL3V0aWxzL2hhbW1lcic7XG5cbmltcG9ydCBXaGVlbElucHV0IGZyb20gJy4vaW5wdXRzL3doZWVsLWlucHV0JztcbmltcG9ydCBNb3ZlSW5wdXQgZnJvbSAnLi9pbnB1dHMvbW92ZS1pbnB1dCc7XG5pbXBvcnQgS2V5SW5wdXQgZnJvbSAnLi9pbnB1dHMva2V5LWlucHV0JztcblxuaW1wb3J0IHtcbiAgQkFTSUNfRVZFTlRfQUxJQVNFUyxcbiAgRVZFTlRfUkVDT0dOSVpFUl9NQVAsXG4gIEdFU1RVUkVfRVZFTlRfQUxJQVNFUyxcbiAgUkVDT0dOSVpFUlMsXG4gIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAsXG4gIFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuaW1wb3J0IHt3aGljaEJ1dHRvbnMsIGdldE9mZnNldFBvc2l0aW9ufSBmcm9tICcuL3V0aWxzL2V2ZW50LXV0aWxzJztcblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZ0KSB7XG4gIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG4vLyBVbmlmaWVkIEFQSSBmb3Igc3Vic2NyaWJpbmcgdG8gZXZlbnRzIGFib3V0IGJvdGhcbi8vIGJhc2ljIGlucHV0IGV2ZW50cyAoZS5nLiAnbW91c2Vtb3ZlJywgJ3RvdWNoc3RhcnQnLCAnd2hlZWwnKVxuLy8gYW5kIGdlc3R1cmFsIGlucHV0IChlLmcuICdjbGljaycsICd0YXAnLCAncGFuc3RhcnQnKS5cbi8vIERlbGVnYXRlcyBnZXN0dXJlIHJlbGF0ZWQgZXZlbnQgcmVnaXN0cmF0aW9uIGFuZCBoYW5kbGluZyB0byBIYW1tZXIuanMuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50ID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcblxuICAgIHRoaXMuX29uQmFzaWNJbnB1dCA9IHRoaXMuX29uQmFzaWNJbnB1dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uT3RoZXJFdmVudCA9IHRoaXMuX29uT3RoZXJFdmVudC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5zZXRFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgLy8gUmVnaXN0ZXIgYWxsIHBhc3NlZCBldmVudHMuXG4gICAgY29uc3Qge2V2ZW50c30gPSBvcHRpb25zO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIHRoaXMub24oZXZlbnRzKTtcbiAgICB9XG4gIH1cblxuICBzZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAvLyB1bnJlZ2lzdGVyIGFsbCBldmVudHNcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgTWFuYWdlckNsYXNzID0gb3B0aW9ucy5NYW5hZ2VyIHx8IE1hbmFnZXI7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlckNsYXNzKGVsZW1lbnQsIHtyZWNvZ25pemVyczogb3B0aW9ucy5yZWNvZ25pemVycyB8fCBSRUNPR05JWkVSU30pXG4gICAgICAub24oJ2hhbW1lci5pbnB1dCcsIHRoaXMuX29uQmFzaWNJbnB1dCk7XG5cbiAgICBpZiAoIW9wdGlvbnMucmVjb2duaXplcnMpIHtcbiAgICAgIC8vIFNldCBkZWZhdWx0IHJlY29nbml6ZSB3aXRoc1xuICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemUtd2l0aC9cbiAgICAgIE9iamVjdC5rZXlzKFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVApLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY29nbml6ZXIgPSB0aGlzLm1hbmFnZXIuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVBbbmFtZV0uZm9yRWFjaChvdGhlck5hbWUgPT4ge1xuICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKG90aGVyTmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBldmVudHMgbm90IGhhbmRsZWQgYnkgSGFtbWVyLmpzOlxuICAgIC8vIC0gbW91c2Ugd2hlZWxcbiAgICAvLyAtIHBvaW50ZXIvdG91Y2gvbW91c2UgbW92ZVxuICAgIHRoaXMud2hlZWxJbnB1dCA9IG5ldyBXaGVlbElucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcbiAgICB0aGlzLm1vdmVJbnB1dCA9IG5ldyBNb3ZlSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7ZW5hYmxlOiBmYWxzZX0pO1xuICAgIHRoaXMua2V5SW5wdXQgPSBuZXcgS2V5SW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7ZW5hYmxlOiBmYWxzZX0pO1xuXG4gICAgaWYgKG9wdGlvbnMucmlnaHRCdXR0b24pIHtcbiAgICAgIC8vIEJsb2NrIHJpZ2h0IGNsaWNrXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBleGlzdGluZyBldmVudHNcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCgoe3JlY29nbml6ZXJOYW1lLCBldmVudEFsaWFzLCB3cmFwcGVkSGFuZGxlcn0pID0+IHtcbiAgICAgIC8vIEVuYWJsZSByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG4gICAgICB0aGlzLm1hbmFnZXIub24oZXZlbnRBbGlhcywgd3JhcHBlZEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVGVhciBkb3duIGludGVybmFsIGV2ZW50IG1hbmFnZW1lbnQgaW1wbGVtZW50YXRpb25zLlxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcblxuICAgICAgLy8gd2hlZWxJbnB1dCBldGMuIGFyZSBjcmVhdGVkIGluIHNldEVsZW1lbnQoKSBhbmQgdGhlcmVmb3JlXG4gICAgICAvLyBjYW5ub3QgZXhpc3QgaWYgdGhlcmUgaXMgbm8gZWxlbWVudFxuICAgICAgdGhpcy53aGVlbElucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubW92ZUlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMua2V5SW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmRlc3Ryb3koKTtcblxuICAgICAgdGhpcy53aGVlbElucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMubW92ZUlucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMua2V5SW5wdXQgPSBudWxsO1xuICAgICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgb24oZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjRWxlbWVudCA9IGhhbmRsZXI7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvbigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0sIHNyY0VsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcHJldmlvdXNseS1yZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXZlbnQgICBBbiBldmVudCBuYW1lIChTdHJpbmcpIG9yIG1hcCBvZiBldmVudCBuYW1lcyB0byBoYW5kbGVyc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKi9cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGBldmVudGAgaXMgYSBtYXAsIGNhbGwgYG9mZigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIEVuYWJsZS9kaXNhYmxlIHJlY29nbml6ZXIgZm9yIHRoZSBnaXZlbiBldmVudFxuICAgKi9cbiAgX3RvZ2dsZVJlY29nbml6ZXIobmFtZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHttYW5hZ2VyfSA9IHRoaXM7XG4gICAgaWYgKCFtYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChuYW1lKTtcbiAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgcmVjb2duaXplci5zZXQoe2VuYWJsZTogZW5hYmxlZH0pO1xuXG4gICAgICBjb25zdCBmYWxsYmFja1JlY29nbml6ZXJzID0gUkVDT0dOSVpFUl9GQUxMQkFDS19NQVBbbmFtZV07XG4gICAgICBpZiAoZmFsbGJhY2tSZWNvZ25pemVycyAmJiAhdGhpcy5vcHRpb25zLnJlY29nbml6ZXJzKSB7XG4gICAgICAgIC8vIFNldCBkZWZhdWx0IHJlcXVpcmUgZmFpbHVyZXNcbiAgICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZXF1aXJlLWZhaWx1cmUvXG4gICAgICAgIGZhbGxiYWNrUmVjb2duaXplcnMuZm9yRWFjaChvdGhlck5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IG90aGVyUmVjb2duaXplciA9IG1hbmFnZXIuZ2V0KG90aGVyTmFtZSk7XG4gICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoaXMgcmVjb2duaXplciB0byBmYWlsXG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUobmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzIHJlY29nbml6ZXIgdG8gZmFpbFxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLmRyb3BSZXF1aXJlRmFpbHVyZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndoZWVsSW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICAgIHRoaXMubW92ZUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLmtleUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCByZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQgPSBudWxsKSB7XG4gICAgY29uc3Qge21hbmFnZXIsIGV2ZW50SGFuZGxlcnN9ID0gdGhpcztcbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IHRoaXMuX3dyYXBFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQpO1xuICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAvLyBHZXQgcmVjb2duaXplciBmb3IgdGhpcyBldmVudFxuICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAvLyBFbmFibGUgcmVjb2duaXplciBmb3IgdGhpcyBldmVudC5cbiAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKHJlY29nbml6ZXJOYW1lLCB0cnVlKTtcblxuICAgIC8vIEZpbmQgYW5jZXN0b3JzXG4gICAgY29uc3QgYW5jZXN0b3JFdmVudEhhbmRsZXJzID0gZXZlbnRIYW5kbGVycy5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgcmV0dXJuIGVudHJ5LmV2ZW50QWxpYXMgPT09IGV2ZW50QWxpYXMgJiZcbiAgICAgICAgZW50cnkuc3JjRWxlbWVudCAhPT0gc3JjRWxlbWVudCAmJlxuICAgICAgICAoIWVudHJ5LnNyY0VsZW1lbnQgfHwgZW50cnkuc3JjRWxlbWVudC5jb250YWlucyhzcmNFbGVtZW50KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTYXZlIHdyYXBwZWQgaGFuZGxlclxuICAgIGV2ZW50SGFuZGxlcnMucHVzaCh7ZXZlbnQsIGV2ZW50QWxpYXMsIHJlY29nbml6ZXJOYW1lLCBzcmNFbGVtZW50LFxuICAgICAgaGFuZGxlciwgd3JhcHBlZEhhbmRsZXJ9KTtcblxuICAgIC8vIFNvcnQgaGFuZGxlcnMgYnkgRE9NIGhpZXJhcmNoeVxuICAgIC8vIFNvIHRoZSBldmVudCB3aWxsIGFsd2F5cyBmaXJlIGZpcnN0IG9uIGNoaWxkIG5vZGVzXG4gICAgYW5jZXN0b3JFdmVudEhhbmRsZXJzLmZvckVhY2goZW50cnkgPT4gbWFuYWdlci5vZmYoZXZlbnRBbGlhcywgZW50cnkud3JhcHBlZEhhbmRsZXIpKTtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgbWFuYWdlci5vbihldmVudEFsaWFzLCB3cmFwcGVkSGFuZGxlcik7XG4gICAgfVxuICAgIGFuY2VzdG9yRXZlbnRIYW5kbGVycy5mb3JFYWNoKGVudHJ5ID0+IG1hbmFnZXIub24oZXZlbnRBbGlhcywgZW50cnkud3JhcHBlZEhhbmRsZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCBkZXJlZ2lzdHJhdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgKyBoYW5kbGVyLlxuICAgKi9cbiAgX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgIGNvbnN0IHttYW5hZ2VyLCBldmVudEhhbmRsZXJzfSA9IHRoaXM7XG4gICAgbGV0IGV2ZW50SGFuZGxlclJlbW92ZWQgPSBmYWxzZTtcblxuICAgIC8vIEZpbmQgc2F2ZWQgaGFuZGxlciBpZiBhbnkuXG4gICAgZm9yIChsZXQgaSA9IGV2ZW50SGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGV2ZW50SGFuZGxlcnNbaV07XG4gICAgICBpZiAoZW50cnkuZXZlbnQgPT09IGV2ZW50ICYmIGVudHJ5LmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgLy8gRGVyZWdpc3RlciBldmVudCBoYW5kbGVyLlxuICAgICAgICBpZiAobWFuYWdlcikge1xuICAgICAgICAgIG1hbmFnZXIub2ZmKGVudHJ5LmV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgc2F2ZWQgaGFuZGxlclxuICAgICAgICBldmVudEhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXZlbnRIYW5kbGVyUmVtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50SGFuZGxlclJlbW92ZWQpIHtcbiAgICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgICAgLy8gR2V0IHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnRcbiAgICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAgIC8vIERpc2FibGUgcmVjb2duaXplciBpZiBubyBtb3JlIGhhbmRsZXJzIGFyZSBhdHRhY2hlZCB0byBpdHMgZXZlbnRzXG4gICAgICBjb25zdCBpc1JlY29nbml6ZXJVc2VkID0gZXZlbnRIYW5kbGVycy5maW5kKFxuICAgICAgICBlbnRyeSA9PiBlbnRyeS5yZWNvZ25pemVyTmFtZSA9PT0gcmVjb2duaXplck5hbWVcbiAgICAgICk7XG4gICAgICBpZiAoIWlzUmVjb2duaXplclVzZWQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV2ZW50IGhhbmRsZXIgdGhhdCBhbGlhc2VzIGV2ZW50cyBhbmQgYWRkIHByb3BzIGJlZm9yZSBwYXNzaW5nXG4gICAqIHRvIHRoZSByZWFsIGhhbmRsZXIuXG4gICAqL1xuICBfd3JhcEV2ZW50SGFuZGxlcih0eXBlLCBoYW5kbGVyLCBzcmNFbGVtZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICAgIGxldCB7bWpvbG5pckV2ZW50fSA9IGV2ZW50O1xuXG4gICAgICBpZiAoIW1qb2xuaXJFdmVudCkge1xuICAgICAgICBtam9sbmlyRXZlbnQgPSB0aGlzLl9ub3JtYWxpemVFdmVudChldmVudCk7XG4gICAgICAgIGV2ZW50Lm1qb2xuaXJFdmVudCA9IG1qb2xuaXJFdmVudDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNTdG9wcGVkID0gbWpvbG5pckV2ZW50LmhhbmRsZWQgJiYgbWpvbG5pckV2ZW50LmhhbmRsZWQgIT09IHNyY0VsZW1lbnQ7XG5cbiAgICAgIGlmICghaXNTdG9wcGVkKSB7XG4gICAgICAgIGNvbnN0IGlzRnJvbURlY2VuZGFudCA9ICFzcmNFbGVtZW50IHx8IHNyY0VsZW1lbnQuY29udGFpbnMoZXZlbnQuc3JjRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKGlzRnJvbURlY2VuZGFudCkge1xuICAgICAgICAgIGhhbmRsZXIoT2JqZWN0LmFzc2lnbih7fSwgbWpvbG5pckV2ZW50LCB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghbWpvbG5pckV2ZW50LmhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICBtam9sbmlyRXZlbnQuaGFuZGxlZCA9IHNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgaGFtbWVyanMgYW5kIGN1c3RvbSBldmVudHMgdG8gaGF2ZSBwcmVkaWN0YWJsZSBmaWVsZHMuXG4gICAqL1xuICBfbm9ybWFsaXplRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7ZWxlbWVudH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LFxuICAgICAgd2hpY2hCdXR0b25zKGV2ZW50KSxcbiAgICAgIGdldE9mZnNldFBvc2l0aW9uKGV2ZW50LCBlbGVtZW50KSxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgIHJvb3RFbGVtZW50OiBlbGVtZW50XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYmFzaWMgZXZlbnRzIHVzaW5nIHRoZSAnaGFtbWVyLmlucHV0JyBIYW1tZXIuanMgQVBJOlxuICAgKiBCZWZvcmUgcnVubmluZyBSZWNvZ25pemVycywgSGFtbWVyIGVtaXRzIGEgJ2hhbW1lci5pbnB1dCcgZXZlbnRcbiAgICogd2l0aCB0aGUgYmFzaWMgZXZlbnQgaW5mby4gVGhpcyBmdW5jdGlvbiBlbWl0cyBhbGwgYmFzaWMgZXZlbnRzXG4gICAqIGFsaWFzZWQgdG8gdGhlIFwiY2xhc3NcIiBvZiBldmVudCByZWNlaXZlZC5cbiAgICogU2VlIGNvbnN0YW50cy5CQVNJQ19FVkVOVF9DTEFTU0VTIGJhc2ljIGV2ZW50IGNsYXNzIGRlZmluaXRpb25zLlxuICAgKi9cbiAgX29uQmFzaWNJbnB1dChldmVudCkge1xuICAgIGNvbnN0IHtzcmNFdmVudH0gPSBldmVudDtcbiAgICBjb25zdCBhbGlhcyA9IEJBU0lDX0VWRU5UX0FMSUFTRVNbc3JjRXZlbnQudHlwZV07XG4gICAgaWYgKGFsaWFzKSB7XG4gICAgICAvLyBmaXJlIGFsbCBldmVudHMgYWxpYXNlZCB0byBzcmNFdmVudC50eXBlXG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdChhbGlhcywgZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZXZlbnRzIG5vdCBzdXBwb3J0ZWQgYnkgSGFtbWVyLmpzLFxuICAgKiBhbmQgcGlwZSBiYWNrIG91dCB0aHJvdWdoIHNhbWUgKEhhbW1lcikgY2hhbm5lbCB1c2VkIGJ5IG90aGVyIGV2ZW50cy5cbiAgICovXG4gIF9vbk90aGVyRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLm1hbmFnZXIuZW1pdChldmVudC50eXBlLCBldmVudCk7XG4gIH1cbn1cbiJdfQ==