'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hammer = require('./utils/hammer');

var _wheelInput = require('./inputs/wheel-input');

var _wheelInput2 = _interopRequireDefault(_wheelInput);

var _moveInput = require('./inputs/move-input');

var _moveInput2 = _interopRequireDefault(_moveInput);

var _keyInput = require('./inputs/key-input');

var _keyInput2 = _interopRequireDefault(_keyInput);

var _constants = require('./constants');

var _eventUtils = require('./utils/event-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function preventDefault(evt) {
  evt.preventDefault();
}

// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.

var EventManager = function () {
  function EventManager() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, EventManager);

    this.options = options;
    this.eventHandlers = [];

    this._onBasicInput = this._onBasicInput.bind(this);
    this._onOtherEvent = this._onOtherEvent.bind(this);

    this.setElement(element);

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  (0, _createClass3.default)(EventManager, [{
    key: 'setElement',
    value: function setElement(element) {
      var _this = this;

      if (this.element) {
        // unregister all events
        this.destroy();
      }
      this.element = element;
      if (!element) {
        return;
      }

      var options = this.options;

      var ManagerClass = options.Manager || _hammer.Manager;

      this.manager = new ManagerClass(element, { recognizers: options.recognizers || _constants.RECOGNIZERS }).on('hammer.input', this._onBasicInput);

      if (!options.recognizers) {
        // Set default recognize withs
        // http://hammerjs.github.io/recognize-with/
        (0, _keys2.default)(_constants.RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {
          var recognizer = _this.manager.get(name);
          if (recognizer) {
            _constants.RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }

      // Handle events not handled by Hammer.js:
      // - mouse wheel
      // - pointer/touch/mouse move
      this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, { enable: false });
      this.moveInput = new _moveInput2.default(element, this._onOtherEvent, { enable: false });
      this.keyInput = new _keyInput2.default(element, this._onOtherEvent, { enable: false });

      if (options.rightButton) {
        // Block right click
        element.addEventListener('contextmenu', preventDefault);
      }

      // Register all existing events
      this.eventHandlers.forEach(function (_ref) {
        var recognizerName = _ref.recognizerName,
            eventAlias = _ref.eventAlias,
            wrappedHandler = _ref.wrappedHandler;

        // Enable recognizer for this event.
        _this._toggleRecognizer(recognizerName, true);
        _this.manager.on(eventAlias, wrappedHandler);
      });
    }

    // Tear down internal event management implementations.

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.element) {
        this.element.removeEventListener('contextmenu', preventDefault);

        // wheelInput etc. are created in setElement() and therefore
        // cannot exist if there is no element
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.manager.destroy();

        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.manager = null;
        this.element = null;
      }
    }

    // Register an event handler function to be called on `event`.

  }, {
    key: 'on',
    value: function on(event, handler, srcElement) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler, srcElement);
      } else {
        srcElement = handler;
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName], srcElement);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: '_toggleRecognizer',
    value: function _toggleRecognizer(name, enabled) {
      var manager = this.manager;

      if (!manager) {
        return;
      }
      var recognizer = manager.get(name);
      if (recognizer) {
        recognizer.set({ enable: enabled });

        var fallbackRecognizers = _constants.RECOGNIZER_FALLBACK_MAP[name];
        if (fallbackRecognizers && !this.options.recognizers) {
          // Set default require failures
          // http://hammerjs.github.io/require-failure/
          fallbackRecognizers.forEach(function (otherName) {
            var otherRecognizer = manager.get(otherName);
            if (enabled) {
              // Wait for this recognizer to fail
              otherRecognizer.requireFailure(name);
            } else {
              // Do not wait for this recognizer to fail
              otherRecognizer.dropRequireFailure(name);
            }
          });
        }
      }
      this.wheelInput.enableEventType(name, enabled);
      this.moveInput.enableEventType(name, enabled);
      this.keyInput.enableEventType(name, enabled);
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var manager = this.manager,
          eventHandlers = this.eventHandlers;

      var wrappedHandler = this._wrapEventHandler(event, handler, srcElement);
      // Alias to a recognized gesture as necessary.
      var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
      // Get recognizer for this event
      var recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Enable recognizer for this event.
      this._toggleRecognizer(recognizerName, true);

      // Find ancestors
      var ancestorEventHandlers = eventHandlers.filter(function (entry) {
        return entry.eventAlias === eventAlias && entry.srcElement !== srcElement && (!entry.srcElement || entry.srcElement.contains(srcElement));
      });

      // Save wrapped handler
      eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, srcElement: srcElement,
        handler: handler, wrappedHandler: wrappedHandler });

      // Sort handlers by DOM hierarchy
      // So the event will always fire first on child nodes
      ancestorEventHandlers.forEach(function (entry) {
        return manager.off(eventAlias, entry.wrappedHandler);
      });
      if (manager) {
        manager.on(eventAlias, wrappedHandler);
      }
      ancestorEventHandlers.forEach(function (entry) {
        return manager.on(eventAlias, entry.wrappedHandler);
      });
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      var manager = this.manager,
          eventHandlers = this.eventHandlers;

      var eventHandlerRemoved = false;

      // Find saved handler if any.
      for (var i = eventHandlers.length; i--;) {
        var entry = eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          if (manager) {
            manager.off(entry.eventAlias, entry.wrappedHandler);
          }
          // Delete saved handler
          eventHandlers.splice(i, 1);
          eventHandlerRemoved = true;
        }
      }

      if (eventHandlerRemoved) {
        // Alias to a recognized gesture as necessary.
        var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
        // Get recognizer for this event
        var recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        // Disable recognizer if no more handlers are attached to its events
        var isRecognizerUsed = eventHandlers.find(function (entry) {
          return entry.recognizerName === recognizerName;
        });
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler, srcElement) {
      var _this2 = this;

      return function (event) {
        var mjolnirEvent = event.mjolnirEvent;


        if (!mjolnirEvent) {
          mjolnirEvent = _this2._normalizeEvent(event);
          event.mjolnirEvent = mjolnirEvent;
        }

        var isStopped = mjolnirEvent.handled && mjolnirEvent.handled !== srcElement;

        if (!isStopped) {
          var isFromDecendant = !srcElement || srcElement.contains(event.srcEvent.target);
          if (isFromDecendant) {
            handler((0, _assign2.default)({}, mjolnirEvent, {
              type: type,
              stopPropagation: function stopPropagation() {
                if (!mjolnirEvent.handled) {
                  mjolnirEvent.handled = srcElement;
                }
              }
            }));
          }
        }
      };
    }

    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */

  }, {
    key: '_normalizeEvent',
    value: function _normalizeEvent(event) {
      var element = this.element;


      return (0, _assign2.default)({}, event, (0, _eventUtils.whichButtons)(event), (0, _eventUtils.getOffsetPosition)(event, element), {
        handled: false,
        rootElement: element
      });
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        this.manager.emit(alias, event);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);
  return EventManager;
}();

exports.default = EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ldmVudC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbInByZXZlbnREZWZhdWx0IiwiZXZ0IiwiRXZlbnRNYW5hZ2VyIiwiZWxlbWVudCIsIm9wdGlvbnMiLCJldmVudEhhbmRsZXJzIiwiX29uQmFzaWNJbnB1dCIsImJpbmQiLCJfb25PdGhlckV2ZW50Iiwic2V0RWxlbWVudCIsImV2ZW50cyIsIm9uIiwiZGVzdHJveSIsIk1hbmFnZXJDbGFzcyIsIk1hbmFnZXIiLCJtYW5hZ2VyIiwicmVjb2duaXplcnMiLCJmb3JFYWNoIiwicmVjb2duaXplciIsImdldCIsIm5hbWUiLCJyZWNvZ25pemVXaXRoIiwib3RoZXJOYW1lIiwid2hlZWxJbnB1dCIsImVuYWJsZSIsIm1vdmVJbnB1dCIsImtleUlucHV0IiwicmlnaHRCdXR0b24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVjb2duaXplck5hbWUiLCJldmVudEFsaWFzIiwid3JhcHBlZEhhbmRsZXIiLCJfdG9nZ2xlUmVjb2duaXplciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudCIsImhhbmRsZXIiLCJzcmNFbGVtZW50IiwiX2FkZEV2ZW50SGFuZGxlciIsImV2ZW50TmFtZSIsIl9yZW1vdmVFdmVudEhhbmRsZXIiLCJlbmFibGVkIiwic2V0IiwiZmFsbGJhY2tSZWNvZ25pemVycyIsIm90aGVyUmVjb2duaXplciIsInJlcXVpcmVGYWlsdXJlIiwiZHJvcFJlcXVpcmVGYWlsdXJlIiwiZW5hYmxlRXZlbnRUeXBlIiwiX3dyYXBFdmVudEhhbmRsZXIiLCJhbmNlc3RvckV2ZW50SGFuZGxlcnMiLCJmaWx0ZXIiLCJlbnRyeSIsImNvbnRhaW5zIiwicHVzaCIsIm9mZiIsImV2ZW50SGFuZGxlclJlbW92ZWQiLCJpIiwibGVuZ3RoIiwic3BsaWNlIiwiaXNSZWNvZ25pemVyVXNlZCIsImZpbmQiLCJ0eXBlIiwibWpvbG5pckV2ZW50IiwiX25vcm1hbGl6ZUV2ZW50IiwiaXNTdG9wcGVkIiwiaGFuZGxlZCIsImlzRnJvbURlY2VuZGFudCIsInNyY0V2ZW50IiwidGFyZ2V0Iiwic3RvcFByb3BhZ2F0aW9uIiwicm9vdEVsZW1lbnQiLCJhbGlhcyIsImVtaXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7O0FBU0E7Ozs7QUFuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbUJBLFNBQVNBLGNBQVQsQ0FBd0JDLEdBQXhCLEVBQTZCO0FBQzNCQSxNQUFJRCxjQUFKO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0lBQ3FCRSxZO0FBQ25CLDBCQUEwQztBQUFBLFFBQTlCQyxPQUE4Qix1RUFBcEIsSUFBb0I7QUFBQSxRQUFkQyxPQUFjLHVFQUFKLEVBQUk7QUFBQTs7QUFDeEMsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixFQUFyQjs7QUFFQSxTQUFLQyxhQUFMLEdBQXFCLEtBQUtBLGFBQUwsQ0FBbUJDLElBQW5CLENBQXdCLElBQXhCLENBQXJCO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixLQUFLQSxhQUFMLENBQW1CRCxJQUFuQixDQUF3QixJQUF4QixDQUFyQjs7QUFFQSxTQUFLRSxVQUFMLENBQWdCTixPQUFoQjs7QUFFQTtBQVR3QyxRQVVqQ08sTUFWaUMsR0FVdkJOLE9BVnVCLENBVWpDTSxNQVZpQzs7QUFXeEMsUUFBSUEsTUFBSixFQUFZO0FBQ1YsV0FBS0MsRUFBTCxDQUFRRCxNQUFSO0FBQ0Q7QUFDRjs7OzsrQkFFVVAsTyxFQUFTO0FBQUE7O0FBQ2xCLFVBQUksS0FBS0EsT0FBVCxFQUFrQjtBQUNoQjtBQUNBLGFBQUtTLE9BQUw7QUFDRDtBQUNELFdBQUtULE9BQUwsR0FBZUEsT0FBZjtBQUNBLFVBQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1o7QUFDRDs7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QUFBLFVBQ1pnQyxRQURZLEdBQ0FoQyxLQURBLENBQ1pnQyxRQURZOztBQUVuQixVQUFNSSxRQUFRLCtCQUFvQkosU0FBU04sSUFBN0IsQ0FBZDtBQUNBLFVBQUlVLEtBQUosRUFBVztBQUNUO0FBQ0EsYUFBS3ZELE9BQUwsQ0FBYXdELElBQWIsQ0FBa0JELEtBQWxCLEVBQXlCcEMsS0FBekI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O2tDQUljQSxLLEVBQU87QUFDbkIsV0FBS25CLE9BQUwsQ0FBYXdELElBQWIsQ0FBa0JyQyxNQUFNMEIsSUFBeEIsRUFBOEIxQixLQUE5QjtBQUNEOzs7OztrQkE3UmtCaEMsWSIsImZpbGUiOiJldmVudC1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtNYW5hZ2VyfSBmcm9tICcuL3V0aWxzL2hhbW1lcic7XG5cbmltcG9ydCBXaGVlbElucHV0IGZyb20gJy4vaW5wdXRzL3doZWVsLWlucHV0JztcbmltcG9ydCBNb3ZlSW5wdXQgZnJvbSAnLi9pbnB1dHMvbW92ZS1pbnB1dCc7XG5pbXBvcnQgS2V5SW5wdXQgZnJvbSAnLi9pbnB1dHMva2V5LWlucHV0JztcblxuaW1wb3J0IHtcbiAgQkFTSUNfRVZFTlRfQUxJQVNFUyxcbiAgRVZFTlRfUkVDT0dOSVpFUl9NQVAsXG4gIEdFU1RVUkVfRVZFTlRfQUxJQVNFUyxcbiAgUkVDT0dOSVpFUlMsXG4gIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAsXG4gIFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuaW1wb3J0IHt3aGljaEJ1dHRvbnMsIGdldE9mZnNldFBvc2l0aW9ufSBmcm9tICcuL3V0aWxzL2V2ZW50LXV0aWxzJztcblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZ0KSB7XG4gIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG4vLyBVbmlmaWVkIEFQSSBmb3Igc3Vic2NyaWJpbmcgdG8gZXZlbnRzIGFib3V0IGJvdGhcbi8vIGJhc2ljIGlucHV0IGV2ZW50cyAoZS5nLiAnbW91c2Vtb3ZlJywgJ3RvdWNoc3RhcnQnLCAnd2hlZWwnKVxuLy8gYW5kIGdlc3R1cmFsIGlucHV0IChlLmcuICdjbGljaycsICd0YXAnLCAncGFuc3RhcnQnKS5cbi8vIERlbGVnYXRlcyBnZXN0dXJlIHJlbGF0ZWQgZXZlbnQgcmVnaXN0cmF0aW9uIGFuZCBoYW5kbGluZyB0byBIYW1tZXIuanMuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50ID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcblxuICAgIHRoaXMuX29uQmFzaWNJbnB1dCA9IHRoaXMuX29uQmFzaWNJbnB1dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uT3RoZXJFdmVudCA9IHRoaXMuX29uT3RoZXJFdmVudC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5zZXRFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgLy8gUmVnaXN0ZXIgYWxsIHBhc3NlZCBldmVudHMuXG4gICAgY29uc3Qge2V2ZW50c30gPSBvcHRpb25zO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIHRoaXMub24oZXZlbnRzKTtcbiAgICB9XG4gIH1cblxuICBzZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAvLyB1bnJlZ2lzdGVyIGFsbCBldmVudHNcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgTWFuYWdlckNsYXNzID0gb3B0aW9ucy5NYW5hZ2VyIHx8IE1hbmFnZXI7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlckNsYXNzKGVsZW1lbnQsIHtyZWNvZ25pemVyczogb3B0aW9ucy5yZWNvZ25pemVycyB8fCBSRUNPR05JWkVSU30pXG4gICAgICAub24oJ2hhbW1lci5pbnB1dCcsIHRoaXMuX29uQmFzaWNJbnB1dCk7XG5cbiAgICBpZiAoIW9wdGlvbnMucmVjb2duaXplcnMpIHtcbiAgICAgIC8vIFNldCBkZWZhdWx0IHJlY29nbml6ZSB3aXRoc1xuICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemUtd2l0aC9cbiAgICAgIE9iamVjdC5rZXlzKFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVApLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY29nbml6ZXIgPSB0aGlzLm1hbmFnZXIuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVBbbmFtZV0uZm9yRWFjaChvdGhlck5hbWUgPT4ge1xuICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKG90aGVyTmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBldmVudHMgbm90IGhhbmRsZWQgYnkgSGFtbWVyLmpzOlxuICAgIC8vIC0gbW91c2Ugd2hlZWxcbiAgICAvLyAtIHBvaW50ZXIvdG91Y2gvbW91c2UgbW92ZVxuICAgIHRoaXMud2hlZWxJbnB1dCA9IG5ldyBXaGVlbElucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcbiAgICB0aGlzLm1vdmVJbnB1dCA9IG5ldyBNb3ZlSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7ZW5hYmxlOiBmYWxzZX0pO1xuICAgIHRoaXMua2V5SW5wdXQgPSBuZXcgS2V5SW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7ZW5hYmxlOiBmYWxzZX0pO1xuXG4gICAgaWYgKG9wdGlvbnMucmlnaHRCdXR0b24pIHtcbiAgICAgIC8vIEJsb2NrIHJpZ2h0IGNsaWNrXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBleGlzdGluZyBldmVudHNcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCgoe3JlY29nbml6ZXJOYW1lLCBldmVudEFsaWFzLCB3cmFwcGVkSGFuZGxlcn0pID0+IHtcbiAgICAgIC8vIEVuYWJsZSByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG4gICAgICB0aGlzLm1hbmFnZXIub24oZXZlbnRBbGlhcywgd3JhcHBlZEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVGVhciBkb3duIGludGVybmFsIGV2ZW50IG1hbmFnZW1lbnQgaW1wbGVtZW50YXRpb25zLlxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcblxuICAgICAgLy8gd2hlZWxJbnB1dCBldGMuIGFyZSBjcmVhdGVkIGluIHNldEVsZW1lbnQoKSBhbmQgdGhlcmVmb3JlXG4gICAgICAvLyBjYW5ub3QgZXhpc3QgaWYgdGhlcmUgaXMgbm8gZWxlbWVudFxuICAgICAgdGhpcy53aGVlbElucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubW92ZUlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMua2V5SW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmRlc3Ryb3koKTtcblxuICAgICAgdGhpcy53aGVlbElucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMubW92ZUlucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMua2V5SW5wdXQgPSBudWxsO1xuICAgICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgb24oZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjRWxlbWVudCA9IGhhbmRsZXI7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvbigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0sIHNyY0VsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcHJldmlvdXNseS1yZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXZlbnQgICBBbiBldmVudCBuYW1lIChTdHJpbmcpIG9yIG1hcCBvZiBldmVudCBuYW1lcyB0byBoYW5kbGVyc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKi9cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGBldmVudGAgaXMgYSBtYXAsIGNhbGwgYG9mZigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIEVuYWJsZS9kaXNhYmxlIHJlY29nbml6ZXIgZm9yIHRoZSBnaXZlbiBldmVudFxuICAgKi9cbiAgX3RvZ2dsZVJlY29nbml6ZXIobmFtZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHttYW5hZ2VyfSA9IHRoaXM7XG4gICAgaWYgKCFtYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChuYW1lKTtcbiAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgcmVjb2duaXplci5zZXQoe2VuYWJsZTogZW5hYmxlZH0pO1xuXG4gICAgICBjb25zdCBmYWxsYmFja1JlY29nbml6ZXJzID0gUkVDT0dOSVpFUl9GQUxMQkFDS19NQVBbbmFtZV07XG4gICAgICBpZiAoZmFsbGJhY2tSZWNvZ25pemVycyAmJiAhdGhpcy5vcHRpb25zLnJlY29nbml6ZXJzKSB7XG4gICAgICAgIC8vIFNldCBkZWZhdWx0IHJlcXVpcmUgZmFpbHVyZXNcbiAgICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZXF1aXJlLWZhaWx1cmUvXG4gICAgICAgIGZhbGxiYWNrUmVjb2duaXplcnMuZm9yRWFjaChvdGhlck5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IG90aGVyUmVjb2duaXplciA9IG1hbmFnZXIuZ2V0KG90aGVyTmFtZSk7XG4gICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoaXMgcmVjb2duaXplciB0byBmYWlsXG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUobmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzIHJlY29nbml6ZXIgdG8gZmFpbFxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLmRyb3BSZXF1aXJlRmFpbHVyZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndoZWVsSW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICAgIHRoaXMubW92ZUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLmtleUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCByZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQgPSBudWxsKSB7XG4gICAgY29uc3Qge21hbmFnZXIsIGV2ZW50SGFuZGxlcnN9ID0gdGhpcztcbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IHRoaXMuX3dyYXBFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQpO1xuICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAvLyBHZXQgcmVjb2duaXplciBmb3IgdGhpcyBldmVudFxuICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAvLyBFbmFibGUgcmVjb2duaXplciBmb3IgdGhpcyBldmVudC5cbiAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKHJlY29nbml6ZXJOYW1lLCB0cnVlKTtcblxuICAgIC8vIEZpbmQgYW5jZXN0b3JzXG4gICAgY29uc3QgYW5jZXN0b3JFdmVudEhhbmRsZXJzID0gZXZlbnRIYW5kbGVycy5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgcmV0dXJuIGVudHJ5LmV2ZW50QWxpYXMgPT09IGV2ZW50QWxpYXMgJiZcbiAgICAgICAgZW50cnkuc3JjRWxlbWVudCAhPT0gc3JjRWxlbWVudCAmJlxuICAgICAgICAoIWVudHJ5LnNyY0VsZW1lbnQgfHwgZW50cnkuc3JjRWxlbWVudC5jb250YWlucyhzcmNFbGVtZW50KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTYXZlIHdyYXBwZWQgaGFuZGxlclxuICAgIGV2ZW50SGFuZGxlcnMucHVzaCh7ZXZlbnQsIGV2ZW50QWxpYXMsIHJlY29nbml6ZXJOYW1lLCBzcmNFbGVtZW50LFxuICAgICAgaGFuZGxlciwgd3JhcHBlZEhhbmRsZXJ9KTtcblxuICAgIC8vIFNvcnQgaGFuZGxlcnMgYnkgRE9NIGhpZXJhcmNoeVxuICAgIC8vIFNvIHRoZSBldmVudCB3aWxsIGFsd2F5cyBmaXJlIGZpcnN0IG9uIGNoaWxkIG5vZGVzXG4gICAgYW5jZXN0b3JFdmVudEhhbmRsZXJzLmZvckVhY2goZW50cnkgPT4gbWFuYWdlci5vZmYoZXZlbnRBbGlhcywgZW50cnkud3JhcHBlZEhhbmRsZXIpKTtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgbWFuYWdlci5vbihldmVudEFsaWFzLCB3cmFwcGVkSGFuZGxlcik7XG4gICAgfVxuICAgIGFuY2VzdG9yRXZlbnRIYW5kbGVycy5mb3JFYWNoKGVudHJ5ID0+IG1hbmFnZXIub24oZXZlbnRBbGlhcywgZW50cnkud3JhcHBlZEhhbmRsZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCBkZXJlZ2lzdHJhdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgKyBoYW5kbGVyLlxuICAgKi9cbiAgX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgIGNvbnN0IHttYW5hZ2VyLCBldmVudEhhbmRsZXJzfSA9IHRoaXM7XG4gICAgbGV0IGV2ZW50SGFuZGxlclJlbW92ZWQgPSBmYWxzZTtcblxuICAgIC8vIEZpbmQgc2F2ZWQgaGFuZGxlciBpZiBhbnkuXG4gICAgZm9yIChsZXQgaSA9IGV2ZW50SGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGV2ZW50SGFuZGxlcnNbaV07XG4gICAgICBpZiAoZW50cnkuZXZlbnQgPT09IGV2ZW50ICYmIGVudHJ5LmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgLy8gRGVyZWdpc3RlciBldmVudCBoYW5kbGVyLlxuICAgICAgICBpZiAobWFuYWdlcikge1xuICAgICAgICAgIG1hbmFnZXIub2ZmKGVudHJ5LmV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgc2F2ZWQgaGFuZGxlclxuICAgICAgICBldmVudEhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXZlbnRIYW5kbGVyUmVtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50SGFuZGxlclJlbW92ZWQpIHtcbiAgICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgICAgLy8gR2V0IHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnRcbiAgICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAgIC8vIERpc2FibGUgcmVjb2duaXplciBpZiBubyBtb3JlIGhhbmRsZXJzIGFyZSBhdHRhY2hlZCB0byBpdHMgZXZlbnRzXG4gICAgICBjb25zdCBpc1JlY29nbml6ZXJVc2VkID0gZXZlbnRIYW5kbGVycy5maW5kKFxuICAgICAgICBlbnRyeSA9PiBlbnRyeS5yZWNvZ25pemVyTmFtZSA9PT0gcmVjb2duaXplck5hbWVcbiAgICAgICk7XG4gICAgICBpZiAoIWlzUmVjb2duaXplclVzZWQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV2ZW50IGhhbmRsZXIgdGhhdCBhbGlhc2VzIGV2ZW50cyBhbmQgYWRkIHByb3BzIGJlZm9yZSBwYXNzaW5nXG4gICAqIHRvIHRoZSByZWFsIGhhbmRsZXIuXG4gICAqL1xuICBfd3JhcEV2ZW50SGFuZGxlcih0eXBlLCBoYW5kbGVyLCBzcmNFbGVtZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICAgIGxldCB7bWpvbG5pckV2ZW50fSA9IGV2ZW50O1xuXG4gICAgICBpZiAoIW1qb2xuaXJFdmVudCkge1xuICAgICAgICBtam9sbmlyRXZlbnQgPSB0aGlzLl9ub3JtYWxpemVFdmVudChldmVudCk7XG4gICAgICAgIGV2ZW50Lm1qb2xuaXJFdmVudCA9IG1qb2xuaXJFdmVudDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNTdG9wcGVkID0gbWpvbG5pckV2ZW50LmhhbmRsZWQgJiYgbWpvbG5pckV2ZW50LmhhbmRsZWQgIT09IHNyY0VsZW1lbnQ7XG5cbiAgICAgIGlmICghaXNTdG9wcGVkKSB7XG4gICAgICAgIGNvbnN0IGlzRnJvbURlY2VuZGFudCA9ICFzcmNFbGVtZW50IHx8IHNyY0VsZW1lbnQuY29udGFpbnMoZXZlbnQuc3JjRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKGlzRnJvbURlY2VuZGFudCkge1xuICAgICAgICAgIGhhbmRsZXIoT2JqZWN0LmFzc2lnbih7fSwgbWpvbG5pckV2ZW50LCB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghbWpvbG5pckV2ZW50LmhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICBtam9sbmlyRXZlbnQuaGFuZGxlZCA9IHNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgaGFtbWVyanMgYW5kIGN1c3RvbSBldmVudHMgdG8gaGF2ZSBwcmVkaWN0YWJsZSBmaWVsZHMuXG4gICAqL1xuICBfbm9ybWFsaXplRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7ZWxlbWVudH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LFxuICAgICAgd2hpY2hCdXR0b25zKGV2ZW50KSxcbiAgICAgIGdldE9mZnNldFBvc2l0aW9uKGV2ZW50LCBlbGVtZW50KSxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgIHJvb3RFbGVtZW50OiBlbGVtZW50XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYmFzaWMgZXZlbnRzIHVzaW5nIHRoZSAnaGFtbWVyLmlucHV0JyBIYW1tZXIuanMgQVBJOlxuICAgKiBCZWZvcmUgcnVubmluZyBSZWNvZ25pemVycywgSGFtbWVyIGVtaXRzIGEgJ2hhbW1lci5pbnB1dCcgZXZlbnRcbiAgICogd2l0aCB0aGUgYmFzaWMgZXZlbnQgaW5mby4gVGhpcyBmdW5jdGlvbiBlbWl0cyBhbGwgYmFzaWMgZXZlbnRzXG4gICAqIGFsaWFzZWQgdG8gdGhlIFwiY2xhc3NcIiBvZiBldmVudCByZWNlaXZlZC5cbiAgICogU2VlIGNvbnN0YW50cy5CQVNJQ19FVkVOVF9DTEFTU0VTIGJhc2ljIGV2ZW50IGNsYXNzIGRlZmluaXRpb25zLlxuICAgKi9cbiAgX29uQmFzaWNJbnB1dChldmVudCkge1xuICAgIGNvbnN0IHtzcmNFdmVudH0gPSBldmVudDtcbiAgICBjb25zdCBhbGlhcyA9IEJBU0lDX0VWRU5UX0FMSUFTRVNbc3JjRXZlbnQudHlwZV07XG4gICAgaWYgKGFsaWFzKSB7XG4gICAgICAvLyBmaXJlIGFsbCBldmVudHMgYWxpYXNlZCB0byBzcmNFdmVudC50eXBlXG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdChhbGlhcywgZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZXZlbnRzIG5vdCBzdXBwb3J0ZWQgYnkgSGFtbWVyLmpzLFxuICAgKiBhbmQgcGlwZSBiYWNrIG91dCB0aHJvdWdoIHNhbWUgKEhhbW1lcikgY2hhbm5lbCB1c2VkIGJ5IG90aGVyIGV2ZW50cy5cbiAgICovXG4gIF9vbk90aGVyRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLm1hbmFnZXIuZW1pdChldmVudC50eXBlLCBldmVudCk7XG4gIH1cbn1cbiJdfQ==