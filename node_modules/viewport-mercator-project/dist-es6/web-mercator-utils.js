var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE

import { Vector3 } from 'math.gl';
import { createMat4, transformVector } from './math-utils';

import mat4_perspective from 'gl-mat4/perspective';
import mat4_scale from 'gl-mat4/scale';
import mat4_translate from 'gl-mat4/translate';
import mat4_rotateX from 'gl-mat4/rotateX';
import mat4_rotateZ from 'gl-mat4/rotateZ';
import vec2_lerp from 'gl-vec2/lerp';
import assert from 'assert';

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
// Average circumference (40075 km equatorial, 40007 km meridional)
var EARTH_CIRCUMFERENCE = 40.03e6;

/** Util functions **/
export function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}

export function scaleToZoom(scale) {
  return Math.log2(scale);
}

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */
export function lngLatToWorld(_ref, scale) {
  var _ref2 = _slicedToArray(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  scale *= TILE_SIZE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
export function worldToLngLat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale *= TILE_SIZE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

// Returns the zoom level that gives a 1 meter pixel at a certain latitude
// S=C*cos(y)/2^(z+8)
export function getMeterZoom(_ref5) {
  var latitude = _ref5.latitude;

  assert(Number.isFinite(latitude));
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 8;
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
export function getDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      zoom = _ref6.zoom,
      scale = _ref6.scale,
      _ref6$highPrecision = _ref6.highPrecision,
      highPrecision = _ref6$highPrecision === undefined ? false : _ref6$highPrecision;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : zoomToScale(zoom);

  assert(Number.isFinite(latitude) && Number.isFinite(longitude) && Number.isFinite(scale));

  var result = {};
  var worldSize = TILE_SIZE * scale;
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);

  /**
   * Number of pixels occupied by one degree longitude around current lat/lon:
     pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
       = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
     pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
       = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
   */
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;

  /**
   * Number of pixels occupied by one meter around current lat/lon:
   */
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;

  result.pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / altPixelsPerMeter];

  result.pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  /**
   * Taylor series 2nd order for 1/latCosine
     f'(a) * (x - a)
       = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
       = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
   */
  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;

    result.pixelsPerDegree2 = [0, pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
  }

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return result;
}

/**
 * Calculates a mercator world position ("pixels" in given zoom level)
 * from a lng/lat and meterOffset
 */
export function getWorldPosition(_ref7) {
  var longitude = _ref7.longitude,
      latitude = _ref7.latitude,
      zoom = _ref7.zoom,
      scale = _ref7.scale,
      meterOffset = _ref7.meterOffset,
      _ref7$distanceScales = _ref7.distanceScales,
      distanceScales = _ref7$distanceScales === undefined ? null : _ref7$distanceScales;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : zoomToScale(zoom);

  // Make a centered version of the matrix for projection modes without an offset
  var center2d = lngLatToWorld([longitude, latitude], scale);
  var center = new Vector3(center2d[0], center2d[1], 0);

  if (meterOffset) {
    // Calculate distance scales if lng/lat/zoom are provided
    distanceScales = distanceScales || getDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var pixelPosition = new Vector3(meterOffset)
    // Convert to pixels in current zoom
    .scale(distanceScales.pixelsPerMeter)
    // We want positive Y to represent an offset towards north,
    // but web mercator world coordinates is top-left
    .scale([1, -1, 1]);
    center.add(pixelPosition);
  }

  return center;
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

export function getViewMatrix(_ref10) {
  var height = _ref10.height,
      pitch = _ref10.pitch,
      bearing = _ref10.bearing,
      altitude = _ref10.altitude,
      _ref10$center = _ref10.center,
      center = _ref10$center === undefined ? null : _ref10$center,
      _ref10$flipY = _ref10.flipY,
      flipY = _ref10$flipY === undefined ? false : _ref10$flipY;


  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
  // Note that mercator world coordinates typically need to be flipped
  //
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = createMat4();

  // Move camera to altitude (along the pitch & bearing direction)
  mat4_translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  mat4_scale(vm, vm, [1, 1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  mat4_rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  mat4_rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);

  if (flipY) {
    mat4_scale(vm, vm, [1, -1, 1]);
  }

  if (center) {
    mat4_translate(vm, vm, new Vector3(center).negate());
  }

  return vm;
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
// This is a "Mapbox" projection matrix - matches mapbox exactly if farZMultiplier === 1
export function getProjectionMatrix(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      pitch = _ref11.pitch,
      altitude = _ref11.altitude,
      _ref11$farZMultiplier = _ref11.farZMultiplier,
      farZMultiplier = _ref11$farZMultiplier === undefined ? 10 : _ref11$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = mat4_perspective([], fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

/**
 * Project flat coordinates to pixels on screen.
 *
 * @param {Array} xyz - flat coordinate on 512*512 Mercator Zoom 0 tile
 * @param {Matrix4} pixelProjectionMatrix - projection matrix
 * @return {Array} [x, y, depth] pixel coordinate on screen.
 */
export function worldToPixels(xyz, pixelProjectionMatrix) {
  var _xyz = _slicedToArray(xyz, 3),
      x = _xyz[0],
      y = _xyz[1],
      _xyz$ = _xyz[2],
      z = _xyz$ === undefined ? 0 : _xyz$;

  assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));

  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);
}

/**
 * Unproject pixels on screen to flat coordinates.
 *
 * @param {Array} xyz - pixel coordinate on screen.
 * @param {Matrix4} pixelUnprojectionMatrix - unprojection matrix
 * @param {Number} targetZ - if pixel coordinate does not have a 3rd component (depth),
 *    targetZ is used as the elevation plane to unproject onto
 * @return {Array} [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.
 */
export function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var _xyz2 = _slicedToArray(xyz, 3),
      x = _xyz2[0],
      y = _xyz2[1],
      z = _xyz2[2];

  assert(Number.isFinite(x) && Number.isFinite(y));

  if (Number.isFinite(z)) {
    // Has depth component
    var coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }

  // since we don't know the correct projected z value for the point,
  // unproject two points to get a line and then find the point on that line with z=0
  var coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);
  var coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);

  var z0 = coord0[2];
  var z1 = coord1[2];

  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2_lerp([], coord0, coord1, t);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3ItdXRpbHMuanMiXSwibmFtZXMiOlsiVmVjdG9yMyIsImNyZWF0ZU1hdDQiLCJ0cmFuc2Zvcm1WZWN0b3IiLCJtYXQ0X3BlcnNwZWN0aXZlIiwibWF0NF9zY2FsZSIsIm1hdDRfdHJhbnNsYXRlIiwibWF0NF9yb3RhdGVYIiwibWF0NF9yb3RhdGVaIiwidmVjMl9sZXJwIiwiYXNzZXJ0IiwiUEkiLCJNYXRoIiwiUElfNCIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlJBRElBTlNfVE9fREVHUkVFUyIsIlRJTEVfU0laRSIsIkVBUlRIX0NJUkNVTUZFUkVOQ0UiLCJ6b29tVG9TY2FsZSIsInpvb20iLCJwb3ciLCJzY2FsZVRvWm9vbSIsInNjYWxlIiwibG9nMiIsImxuZ0xhdFRvV29ybGQiLCJsbmciLCJsYXQiLCJsYW1iZGEyIiwicGhpMiIsIngiLCJ5IiwibG9nIiwidGFuIiwid29ybGRUb0xuZ0xhdCIsImF0YW4iLCJleHAiLCJnZXRNZXRlclpvb20iLCJsYXRpdHVkZSIsIk51bWJlciIsImlzRmluaXRlIiwibGF0Q29zaW5lIiwiY29zIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJsb25naXR1ZGUiLCJoaWdoUHJlY2lzaW9uIiwidW5kZWZpbmVkIiwicmVzdWx0Iiwid29ybGRTaXplIiwicGl4ZWxzUGVyRGVncmVlWCIsInBpeGVsc1BlckRlZ3JlZVkiLCJhbHRQaXhlbHNQZXJNZXRlciIsInBpeGVsc1Blck1ldGVyIiwibWV0ZXJzUGVyUGl4ZWwiLCJwaXhlbHNQZXJEZWdyZWUiLCJkZWdyZWVzUGVyUGl4ZWwiLCJsYXRDb3NpbmUyIiwicGl4ZWxzUGVyRGVncmVlWTIiLCJhbHRQaXhlbHNQZXJEZWdyZWUyIiwiYWx0UGl4ZWxzUGVyTWV0ZXIyIiwicGl4ZWxzUGVyRGVncmVlMiIsInBpeGVsc1Blck1ldGVyMiIsImdldFdvcmxkUG9zaXRpb24iLCJtZXRlck9mZnNldCIsImRpc3RhbmNlU2NhbGVzIiwiY2VudGVyMmQiLCJjZW50ZXIiLCJwaXhlbFBvc2l0aW9uIiwiYWRkIiwiZ2V0Rm92IiwiaGVpZ2h0IiwiYWx0aXR1ZGUiLCJnZXRDbGlwcGluZ1BsYW5lcyIsInBpdGNoIiwicGl0Y2hSYWRpYW5zIiwiaGFsZkZvdiIsInRvcEhhbGZTdXJmYWNlRGlzdGFuY2UiLCJzaW4iLCJmYXJaIiwibmVhcloiLCJnZXRWaWV3TWF0cml4IiwiYmVhcmluZyIsImZsaXBZIiwidm0iLCJuZWdhdGUiLCJnZXRQcm9qZWN0aW9uTWF0cml4Iiwid2lkdGgiLCJmYXJaTXVsdGlwbGllciIsImZvdiIsInByb2plY3Rpb25NYXRyaXgiLCJ3b3JsZFRvUGl4ZWxzIiwieHl6IiwicGl4ZWxQcm9qZWN0aW9uTWF0cml4IiwieiIsInBpeGVsc1RvV29ybGQiLCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeCIsInRhcmdldFoiLCJjb29yZCIsImNvb3JkMCIsImNvb3JkMSIsInowIiwiejEiLCJ0Il0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLFNBQVFBLE9BQVIsUUFBc0IsU0FBdEI7QUFDQSxTQUFRQyxVQUFSLEVBQW9CQyxlQUFwQixRQUEwQyxjQUExQzs7QUFFQSxPQUFPQyxnQkFBUCxNQUE2QixxQkFBN0I7QUFDQSxPQUFPQyxVQUFQLE1BQXVCLGVBQXZCO0FBQ0EsT0FBT0MsY0FBUCxNQUEyQixtQkFBM0I7QUFDQSxPQUFPQyxZQUFQLE1BQXlCLGlCQUF6QjtBQUNBLE9BQU9DLFlBQVAsTUFBeUIsaUJBQXpCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixjQUF0QjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUE7QUFDQSxJQUFNQyxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0E7QUFDQSxJQUFNQyxzQkFBc0IsT0FBNUI7O0FBRUE7QUFDQSxPQUFP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UCxDQUFYOztBQUVBLE1BQU1HLElBQUlGLE9BQU9DLEVBQVAsR0FBWSxDQUFaLEdBQWdCLENBQUMsQ0FBQ0wsV0FBVyxDQUFaLElBQWlCSSxFQUFsQixLQUF5QkMsS0FBS0QsRUFBOUIsQ0FBMUI7QUFDQSxTQUFPMUYsVUFBVSxFQUFWLEVBQWN3RixNQUFkLEVBQXNCQyxNQUF0QixFQUE4QkcsQ0FBOUIsQ0FBUDtBQUNEIiwiZmlsZSI6IndlYi1tZXJjYXRvci11dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8gLSBUSEUgVVRJTElUSUVTIElOIFRISVMgRklMRSBTSE9VTEQgQkUgSU1QT1JURUQgRlJPTSBXRUItTUVSQ0FUT1ItVklFV1BPUlQgTU9EVUxFXG5cbmltcG9ydCB7VmVjdG9yM30gZnJvbSAnbWF0aC5nbCc7XG5pbXBvcnQge2NyZWF0ZU1hdDQsIHRyYW5zZm9ybVZlY3Rvcn0gZnJvbSAnLi9tYXRoLXV0aWxzJztcblxuaW1wb3J0IG1hdDRfcGVyc3BlY3RpdmUgZnJvbSAnZ2wtbWF0NC9wZXJzcGVjdGl2ZSc7XG5pbXBvcnQgbWF0NF9zY2FsZSBmcm9tICdnbC1tYXQ0L3NjYWxlJztcbmltcG9ydCBtYXQ0X3RyYW5zbGF0ZSBmcm9tICdnbC1tYXQ0L3RyYW5zbGF0ZSc7XG5pbXBvcnQgbWF0NF9yb3RhdGVYIGZyb20gJ2dsLW1hdDQvcm90YXRlWCc7XG5pbXBvcnQgbWF0NF9yb3RhdGVaIGZyb20gJ2dsLW1hdDQvcm90YXRlWic7XG5pbXBvcnQgdmVjMl9sZXJwIGZyb20gJ2dsLXZlYzIvbGVycCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG4vLyBBdmVyYWdlIGNpcmN1bWZlcmVuY2UgKDQwMDc1IGttIGVxdWF0b3JpYWwsIDQwMDA3IGttIG1lcmlkaW9uYWwpXG5jb25zdCBFQVJUSF9DSVJDVU1GRVJFTkNFID0gNDAuMDNlNjtcblxuLyoqIFV0aWwgZnVuY3Rpb25zICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21Ub1NjYWxlKHpvb20pIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVUb1pvb20oc2NhbGUpIHtcbiAgcmV0dXJuIE1hdGgubG9nMihzY2FsZSk7XG59XG5cbi8qKlxuICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICogcGVyc3BlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG5nTGF0VG9Xb3JsZChbbG5nLCBsYXRdLCBzY2FsZSkge1xuICBzY2FsZSAqPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBzY2FsZSAqIChQSSAtIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9MbmdMYXQoW3gsIHldLCBzY2FsZSkge1xuICBzY2FsZSAqPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhbWJkYTIgPSAoeCAvIHNjYWxlKSAqICgyICogUEkpIC0gUEk7XG4gIGNvbnN0IHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChQSSAtICh5IC8gc2NhbGUpICogKDIgKiBQSSkpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgZ2l2ZXMgYSAxIG1ldGVyIHBpeGVsIGF0IGEgY2VydGFpbiBsYXRpdHVkZVxuLy8gUz1DKmNvcyh5KS8yXih6KzgpXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0ZXJab29tKHtsYXRpdHVkZX0pIHtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSkpO1xuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIHJldHVybiBzY2FsZVRvWm9vbShFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lKSAtIDg7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpbiBtZXRlcnMgYXJvdW5kIGN1cnJlbnQgbGF0L2xvbiwgYm90aCBmb3JcbiAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAqIEluIG1lcmNhdG9yIHByb2plY3Rpb24gbW9kZSwgdGhlIGRpc3RhbmNlIHNjYWxlcyB2YXJ5IHNpZ25pZmljYW50bHlcbiAqIHdpdGggbGF0aXR1ZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbSwgc2NhbGUsIGhpZ2hQcmVjaXNpb24gPSBmYWxzZX0pIHtcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZyb20gem9vbSBpZiBub3QgcHJvdmlkZWRcbiAgc2NhbGUgPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiB6b29tVG9TY2FsZSh6b29tKTtcblxuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSAmJiBOdW1iZXIuaXNGaW5pdGUobG9uZ2l0dWRlKSAmJiBOdW1iZXIuaXNGaW5pdGUoc2NhbGUpKTtcblxuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKTtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxvbmdpdHVkZSBhcm91bmQgY3VycmVudCBsYXQvbG9uOlxuICAgICBwaXhlbHNQZXJEZWdyZWVYID0gZChsbmdMYXRUb1dvcmxkKFtsbmcsIGxhdF0pWzBdKS9kKGxuZylcbiAgICAgICA9IHNjYWxlICogVElMRV9TSVpFICogREVHUkVFU19UT19SQURJQU5TIC8gKDIgKiBQSSlcbiAgICAgcGl4ZWxzUGVyRGVncmVlWSA9IGQobG5nTGF0VG9Xb3JsZChbbG5nLCBsYXRdKVsxXSkvZChsYXQpXG4gICAgICAgPSAtc2NhbGUgKiBUSUxFX1NJWkUgKiBERUdSRUVTX1RPX1JBRElBTlMgLyBjb3MobGF0ICogREVHUkVFU19UT19SQURJQU5TKSAgLyAoMiAqIFBJKVxuICAgKi9cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWCA9IHdvcmxkU2l6ZSAvIDM2MDtcbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWSA9IHBpeGVsc1BlckRlZ3JlZVggLyBsYXRDb3NpbmU7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIG1ldGVyIGFyb3VuZCBjdXJyZW50IGxhdC9sb246XG4gICAqL1xuICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgLyBsYXRDb3NpbmU7XG5cbiAgcmVzdWx0LnBpeGVsc1Blck1ldGVyID0gW2FsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICByZXN1bHQubWV0ZXJzUGVyUGl4ZWwgPSBbMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlcl07XG5cbiAgcmVzdWx0LnBpeGVsc1BlckRlZ3JlZSA9IFtwaXhlbHNQZXJEZWdyZWVYLCBwaXhlbHNQZXJEZWdyZWVZLCBhbHRQaXhlbHNQZXJNZXRlcl07XG4gIHJlc3VsdC5kZWdyZWVzUGVyUGl4ZWwgPSBbMSAvIHBpeGVsc1BlckRlZ3JlZVgsIDEgLyBwaXhlbHNQZXJEZWdyZWVZLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuXG4gIC8qKlxuICAgKiBUYXlsb3Igc2VyaWVzIDJuZCBvcmRlciBmb3IgMS9sYXRDb3NpbmVcbiAgICAgZicoYSkgKiAoeCAtIGEpXG4gICAgICAgPSBkKDEvY29zKGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUykpL2QobGF0KSAqIGRMYXRcbiAgICAgICA9IERFR1JFRVNfVE9fUkFESUFOUyAqIHRhbihsYXQgKiBERUdSRUVTX1RPX1JBRElBTlMpIC8gY29zKGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUykgKiBkTGF0XG4gICAqL1xuICBpZiAoaGlnaFByZWNpc2lvbikge1xuICAgIGNvbnN0IGxhdENvc2luZTIgPSBERUdSRUVTX1RPX1JBRElBTlMgKiBNYXRoLnRhbihsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUykgLyBsYXRDb3NpbmU7XG4gICAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWTIgPSBwaXhlbHNQZXJEZWdyZWVYICogbGF0Q29zaW5lMiAvIDI7XG4gICAgY29uc3QgYWx0UGl4ZWxzUGVyRGVncmVlMiA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBsYXRDb3NpbmUyO1xuICAgIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyMiA9IGFsdFBpeGVsc1BlckRlZ3JlZTIgLyBwaXhlbHNQZXJEZWdyZWVZICogYWx0UGl4ZWxzUGVyTWV0ZXI7XG5cbiAgICByZXN1bHQucGl4ZWxzUGVyRGVncmVlMiA9IFswLCBwaXhlbHNQZXJEZWdyZWVZMiwgYWx0UGl4ZWxzUGVyRGVncmVlMl07XG4gICAgcmVzdWx0LnBpeGVsc1Blck1ldGVyMiA9IFthbHRQaXhlbHNQZXJNZXRlcjIsIDAsIGFsdFBpeGVsc1Blck1ldGVyMl07XG4gIH1cblxuICAvLyBNYWluIHJlc3VsdHMsIHVzZWQgZm9yIGNvbnZlcnRpbmcgbWV0ZXJzIHRvIGxhdGxuZyBkZWx0YXMgYW5kIHNjYWxpbmcgb2Zmc2V0c1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBtZXJjYXRvciB3b3JsZCBwb3NpdGlvbiAoXCJwaXhlbHNcIiBpbiBnaXZlbiB6b29tIGxldmVsKVxuICogZnJvbSBhIGxuZy9sYXQgYW5kIG1ldGVyT2Zmc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JsZFBvc2l0aW9uKHtcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgem9vbSxcbiAgc2NhbGUsXG4gIG1ldGVyT2Zmc2V0LFxuICBkaXN0YW5jZVNjYWxlcyA9IG51bGxcbn0pIHtcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZyb20gem9vbSBpZiBub3QgcHJvdmlkZWRcbiAgc2NhbGUgPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiB6b29tVG9TY2FsZSh6b29tKTtcblxuICAvLyBNYWtlIGEgY2VudGVyZWQgdmVyc2lvbiBvZiB0aGUgbWF0cml4IGZvciBwcm9qZWN0aW9uIG1vZGVzIHdpdGhvdXQgYW4gb2Zmc2V0XG4gIGNvbnN0IGNlbnRlcjJkID0gbG5nTGF0VG9Xb3JsZChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHNjYWxlKTtcbiAgY29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoY2VudGVyMmRbMF0sIGNlbnRlcjJkWzFdLCAwKTtcblxuICBpZiAobWV0ZXJPZmZzZXQpIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2Ugc2NhbGVzIGlmIGxuZy9sYXQvem9vbSBhcmUgcHJvdmlkZWRcbiAgICBkaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzIHx8IGdldERpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzY2FsZX0pO1xuXG4gICAgY29uc3QgcGl4ZWxQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKG1ldGVyT2Zmc2V0KVxuICAgICAgLy8gQ29udmVydCB0byBwaXhlbHMgaW4gY3VycmVudCB6b29tXG4gICAgICAuc2NhbGUoZGlzdGFuY2VTY2FsZXMucGl4ZWxzUGVyTWV0ZXIpXG4gICAgICAvLyBXZSB3YW50IHBvc2l0aXZlIFkgdG8gcmVwcmVzZW50IGFuIG9mZnNldCB0b3dhcmRzIG5vcnRoLFxuICAgICAgLy8gYnV0IHdlYiBtZXJjYXRvciB3b3JsZCBjb29yZGluYXRlcyBpcyB0b3AtbGVmdFxuICAgICAgLnNjYWxlKFsxLCAtMSwgMV0pO1xuICAgIGNlbnRlci5hZGQocGl4ZWxQb3NpdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2VudGVyO1xufVxuXG4vLyBBVFRSSUJVVElPTjpcbi8vIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGlzIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5cbi8vIFZhcmlhYmxlIGZvdiAoaW4gcmFkaWFucylcbmZ1bmN0aW9uIGdldEZvdih7aGVpZ2h0LCBhbHRpdHVkZX0pIHtcbiAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oKGhlaWdodCAvIDIpIC8gYWx0aXR1ZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BsYW5lcyh7YWx0aXR1ZGUsIHBpdGNofSkge1xuICAvLyBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgcG9pbnQgdG8gdGhlIGNlbnRlciB0b3BcbiAgLy8gaW4gYWx0aXR1ZGUgdW5pdHMgdXNpbmcgbGF3IG9mIHNpbmVzLlxuICBjb25zdCBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSk7XG4gIGNvbnN0IHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPVxuICAgIE1hdGguc2luKGhhbGZGb3YpICogYWx0aXR1ZGUgLyBNYXRoLnNpbihNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGhhbGZGb3YpO1xuXG4gIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgY29uc3QgZmFyWiA9IE1hdGguY29zKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyBhbHRpdHVkZTtcblxuICByZXR1cm4ge2ZhclosIG5lYXJaOiAwLjF9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld01hdHJpeCh7XG4gIC8vIFZpZXdwb3J0IHByb3BzXG4gIGhlaWdodCxcbiAgcGl0Y2gsXG4gIGJlYXJpbmcsXG4gIGFsdGl0dWRlLFxuICAvLyBQcmUtY2FsY3VsYXRlZCBwYXJhbWV0ZXJzXG4gIGNlbnRlciA9IG51bGwsXG4gIC8vIE9wdGlvbnNcbiAgZmxpcFkgPSBmYWxzZVxufSkge1xuXG4gIC8vIFZJRVcgTUFUUklYOiBQUk9KRUNUUyBNRVJDQVRPUiBXT1JMRCBDT09SRElOQVRFU1xuICAvLyBOb3RlIHRoYXQgbWVyY2F0b3Igd29ybGQgY29vcmRpbmF0ZXMgdHlwaWNhbGx5IG5lZWQgdG8gYmUgZmxpcHBlZFxuICAvL1xuICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbiBvcmRlcnMgc2hvdWxkIGJlIHJlYWQgaW4gcmV2ZXJzZVxuICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgLy8gTW92ZSBjYW1lcmEgdG8gYWx0aXR1ZGUgKGFsb25nIHRoZSBwaXRjaCAmIGJlYXJpbmcgZGlyZWN0aW9uKVxuICBtYXQ0X3RyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcblxuICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICBtYXQ0X3NjYWxlKHZtLCB2bSwgWzEsIDEsIDEgLyBoZWlnaHRdKTtcblxuICAvLyBSb3RhdGUgYnkgYmVhcmluZywgYW5kIHRoZW4gYnkgcGl0Y2ggKHdoaWNoIHRpbHRzIHRoZSB2aWV3KVxuICBtYXQ0X3JvdGF0ZVgodm0sIHZtLCAtcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0X3JvdGF0ZVoodm0sIHZtLCBiZWFyaW5nICogREVHUkVFU19UT19SQURJQU5TKTtcblxuICBpZiAoZmxpcFkpIHtcbiAgICBtYXQ0X3NjYWxlKHZtLCB2bSwgWzEsIC0xLCAxXSk7XG4gIH1cblxuICBpZiAoY2VudGVyKSB7XG4gICAgbWF0NF90cmFuc2xhdGUodm0sIHZtLCBuZXcgVmVjdG9yMyhjZW50ZXIpLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIHJldHVybiB2bTtcbn1cblxuLy8gUFJPSkVDVElPTiBNQVRSSVg6IFBST0pFQ1RTIEZST00gQ0FNRVJBIChWSUVXKSBTUEFDRSBUTyBDTElQU1BBQ0Vcbi8vIFRoaXMgaXMgYSBcIk1hcGJveFwiIHByb2plY3Rpb24gbWF0cml4IC0gbWF0Y2hlcyBtYXBib3ggZXhhY3RseSBpZiBmYXJaTXVsdGlwbGllciA9PT0gMVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2plY3Rpb25NYXRyaXgoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYWx0aXR1ZGUsXG4gIGZhclpNdWx0aXBsaWVyID0gMTBcbn0pIHtcbiAgY29uc3Qge25lYXJaLCBmYXJafSA9IGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KTtcbiAgY29uc3QgZm92ID0gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSk7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfcGVyc3BlY3RpdmUoXG4gICAgW10sXG4gICAgZm92LCAgICAgICAgICAgICAgLy8gZm92IGluIHJhZGlhbnNcbiAgICB3aWR0aCAvIGhlaWdodCwgICAvLyBhc3BlY3QgcmF0aW9cbiAgICBuZWFyWiwgICAgICAgICAgICAvLyBuZWFyIHBsYW5lXG4gICAgZmFyWiAqIGZhclpNdWx0aXBsaWVyIC8vIGZhciBwbGFuZVxuICApO1xuXG4gIHJldHVybiBwcm9qZWN0aW9uTWF0cml4O1xufVxuXG4vKipcbiAqIFByb2plY3QgZmxhdCBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gc2NyZWVuLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtIGZsYXQgY29vcmRpbmF0ZSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlXG4gKiBAcGFyYW0ge01hdHJpeDR9IHBpeGVsUHJvamVjdGlvbk1hdHJpeCAtIHByb2plY3Rpb24gbWF0cml4XG4gKiBAcmV0dXJuIHtBcnJheX0gW3gsIHksIGRlcHRoXSBwaXhlbCBjb29yZGluYXRlIG9uIHNjcmVlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9QaXhlbHMoeHl6LCBwaXhlbFByb2plY3Rpb25NYXRyaXgpIHtcbiAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopKTtcblxuICByZXR1cm4gdHJhbnNmb3JtVmVjdG9yKHBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbn1cblxuLyoqXG4gKiBVbnByb2plY3QgcGl4ZWxzIG9uIHNjcmVlbiB0byBmbGF0IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtIHBpeGVsIGNvb3JkaW5hdGUgb24gc2NyZWVuLlxuICogQHBhcmFtIHtNYXRyaXg0fSBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCAtIHVucHJvamVjdGlvbiBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRaIC0gaWYgcGl4ZWwgY29vcmRpbmF0ZSBkb2VzIG5vdCBoYXZlIGEgM3JkIGNvbXBvbmVudCAoZGVwdGgpLFxuICogICAgdGFyZ2V0WiBpcyB1c2VkIGFzIHRoZSBlbGV2YXRpb24gcGxhbmUgdG8gdW5wcm9qZWN0IG9udG9cbiAqIEByZXR1cm4ge0FycmF5fSBbeCwgeSwgWl0gZmxhdCBjb29yZGluYXRlcyBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGl4ZWxzVG9Xb3JsZCh4eXosIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCB0YXJnZXRaID0gMCkge1xuICBjb25zdCBbeCwgeSwgel0gPSB4eXo7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpKTtcblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHopKSB7XG4gICAgLy8gSGFzIGRlcHRoIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvb3JkID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgeiwgMV0pO1xuICAgIHJldHVybiBjb29yZDtcbiAgfVxuXG4gIC8vIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIGNvcnJlY3QgcHJvamVjdGVkIHogdmFsdWUgZm9yIHRoZSBwb2ludCxcbiAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0IGxpbmUgd2l0aCB6PTBcbiAgY29uc3QgY29vcmQwID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMCwgMV0pO1xuICBjb25zdCBjb29yZDEgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCAxLCAxXSk7XG5cbiAgY29uc3QgejAgPSBjb29yZDBbMl07XG4gIGNvbnN0IHoxID0gY29vcmQxWzJdO1xuXG4gIGNvbnN0IHQgPSB6MCA9PT0gejEgPyAwIDogKCh0YXJnZXRaIHx8IDApIC0gejApIC8gKHoxIC0gejApO1xuICByZXR1cm4gdmVjMl9sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG59XG4iXX0=