'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = fitBounds;

var _webMercatorViewport = require('./web-mercator-viewport');

var _webMercatorViewport2 = _interopRequireDefault(_webMercatorViewport);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */
function fitBounds(_ref) {
  var width = _ref.width,
      height = _ref.height,
      bounds = _ref.bounds,
      _ref$padding = _ref.padding,
      padding = _ref$padding === undefined ? 0 : _ref$padding,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? [0, 0] : _ref$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new _webMercatorViewport2.default({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maXQtYm91bmRzLmpzIl0sIm5hbWVzIjpbImZpdEJvdW5kcyIsIndpZHRoIiwiaGVpZ2h0IiwiYm91bmRzIiwicGFkZGluZyIsIm9mZnNldCIsIndlc3QiLCJzb3V0aCIsImVhc3QiLCJub3J0aCIsInZpZXdwb3J0IiwibG9uZ2l0dWRlIiwibGF0aXR1ZGUiLCJ6b29tIiwibnciLCJwcm9qZWN0Iiwic2UiLCJzaXplIiwiTWF0aCIsImFicyIsImNlbnRlciIsInNjYWxlWCIsInNjYWxlWSIsImNlbnRlckxuZ0xhdCIsInVucHJvamVjdCIsImxvZzIiLCJtaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O2tCQWN3QkEsUzs7QUFkeEI7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7QUFZZSxTQUFTQSxTQUFULE9BT1o7QUFBQSxNQU5EQyxLQU1DLFFBTkRBLEtBTUM7QUFBQSxNQUxEQyxNQUtDLFFBTERBLE1BS0M7QUFBQSxNQUpEQyxNQUlDLFFBSkRBLE1BSUM7QUFBQSwwQkFGREMsT0FFQztBQUFBLE1BRkRBLE9BRUMsZ0NBRlMsQ0FFVDtBQUFBLHlCQUREQyxNQUNDO0FBQUEsTUFEREEsTUFDQywrQkFEUSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQ1I7O0FBQUEsK0JBQ3NDRixNQUR0QztBQUFBO0FBQUEsTUFDT0csSUFEUDtBQUFBLE1BQ2FDLEtBRGI7QUFBQTtBQUFBLE1BQ3NCQyxJQUR0QjtBQUFBLE1BQzRCQyxLQUQ1Qjs7QUFHRCxNQUFNQyxXQUFXLGtDQUF3QjtBQUN2Q1QsZ0JBRHVDO0FBRXZDQyxrQkFGdUM7QUFHdkNTLGVBQVcsQ0FINEI7QUFJdkNDLGNBQVUsQ0FKNkI7QUFLdkNDLFVBQU07QUFMaUMsR0FBeEIsQ0FBakI7O0FBUUEsTUFBTUMsS0FBS0osU0FBU0ssT0FBVCxDQUFpQixDQUFDVCxJQUFELEVBQU9HLEtBQVAsQ0FBakIsQ0FBWDtBQUNBLE1BQU1PLEtBQUtOLFNBQVNLLE9BQVQsQ0FBaUIsQ0FBQ1AsSUFBRCxFQUFPRCxLQUFQLENBQWpCLENBQVg7QUFDQSxNQUFNVSxPQUFPLENBQ1hDLEtBQUtDLEdBQUwsQ0FBU0gsR0FBRyxDQUFILElBQVFGLEdBQUcsQ0FBSCxDQUFqQixDQURXLEVBRVhJLEtBQUtDLEdBQUwsQ0FBU0gsR0FBRyxDQUFILElBQVFGLEdBQUcsQ0FBSCxDQUFqQixDQUZXLENBQWI7QUFJQSxNQUFNTSxTQUFTLENBQ2IsQ0FBQ0osR0FBRyxDQUFILElBQVFGLEdBQUcsQ0FBSCxDQUFULElBQWtCLENBREwsRUFFYixDQUFDRSxHQUFHLENBQUgsSUFBUUYsR0FBRyxDQUFILENBQVQsSUFBa0IsQ0FGTCxDQUFmOztBQUtBLE1BQU1PLFNBQVMsQ0FBQ3BCLFFBQVFHLFVBQVUsQ0FBbEIsR0FBc0JjLEtBQUtDLEdBQUwsQ0FBU2QsT0FBTyxDQUFQLENBQVQsSUFBc0IsQ0FBN0MsSUFBa0RZLEtBQUssQ0FBTCxDQUFqRTtBQUNBLE1BQU1LLFNBQVMsQ0FBQ3BCLFNBQVNFLFVBQVUsQ0FBbkIsR0FBdUJjLEtBQUtDLEdBQUwsQ0FBU2QsT0FBTyxDQUFQLENBQVQsSUFBc0IsQ0FBOUMsSUFBbURZLEtBQUssQ0FBTCxDQUFsRTs7QUFFQSxNQUFNTSxlQUFlYixTQUFTYyxTQUFULENBQW1CSixNQUFuQixDQUFyQjtBQUNBLE1BQU1QLE9BQU9ILFNBQVNHLElBQVQsR0FBZ0JLLEtBQUtPLElBQUwsQ0FBVVAsS0FBS0MsR0FBTCxDQUFTRCxLQUFLUSxHQUFMLENBQVNMLE1BQVQsRUFBaUJDLE1BQWpCLENBQVQsQ0FBVixDQUE3Qjs7QUFFQSxTQUFPO0FBQ0xYLGVBQVdZLGFBQWEsQ0FBYixDQUROO0FBRUxYLGNBQVVXLGFBQWEsQ0FBYixDQUZMO0FBR0xWO0FBSEssR0FBUDtBQUtEIiwiZmlsZSI6ImZpdC1ib3VuZHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCBmcm9tICcuL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5cbi8qKlxuICogUmV0dXJucyBtYXAgc2V0dGluZ3Mge2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb219XG4gKiB0aGF0IHdpbGwgY29udGFpbiB0aGUgcHJvdmlkZWQgY29ybmVycyB3aXRoaW4gdGhlIHByb3ZpZGVkIHdpZHRoLlxuICogT25seSBzdXBwb3J0cyBub24tcGVyc3BlY3RpdmUgbW9kZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHZpZXdwb3J0IHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gdmlld3BvcnQgaGVpZ2h0XG4gKiBAcGFyYW0ge0FycmF5fSBib3VuZHMgLSBbW2xvbiwgbGF0XSwgW2xvbiwgbGF0XV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFkZGluZ10gLSBUaGUgYW1vdW50IG9mIHBhZGRpbmcgaW4gcGl4ZWxzIHRvIGFkZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICogQHBhcmFtIHtBcnJheX0gW29mZnNldF0gLSBUaGUgY2VudGVyIG9mIHRoZSBnaXZlbiBib3VuZHMgcmVsYXRpdmUgdG8gdGhlIG1hcCdzIGNlbnRlcixcbiAqICAgIFt4LCB5XSBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIGxhdGl0dWRlLCBsb25naXR1ZGUgYW5kIHpvb21cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZml0Qm91bmRzKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgYm91bmRzLFxuICAvLyBvcHRpb25zXG4gIHBhZGRpbmcgPSAwLFxuICBvZmZzZXQgPSBbMCwgMF1cbn0pIHtcbiAgY29uc3QgW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dID0gYm91bmRzO1xuXG4gIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsb25naXR1ZGU6IDAsXG4gICAgbGF0aXR1ZGU6IDAsXG4gICAgem9vbTogMFxuICB9KTtcblxuICBjb25zdCBudyA9IHZpZXdwb3J0LnByb2plY3QoW3dlc3QsIG5vcnRoXSk7XG4gIGNvbnN0IHNlID0gdmlld3BvcnQucHJvamVjdChbZWFzdCwgc291dGhdKTtcbiAgY29uc3Qgc2l6ZSA9IFtcbiAgICBNYXRoLmFicyhzZVswXSAtIG53WzBdKSxcbiAgICBNYXRoLmFicyhzZVsxXSAtIG53WzFdKVxuICBdO1xuICBjb25zdCBjZW50ZXIgPSBbXG4gICAgKHNlWzBdICsgbndbMF0pIC8gMixcbiAgICAoc2VbMV0gKyBud1sxXSkgLyAyXG4gIF07XG5cbiAgY29uc3Qgc2NhbGVYID0gKHdpZHRoIC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMF0pICogMikgLyBzaXplWzBdO1xuICBjb25zdCBzY2FsZVkgPSAoaGVpZ2h0IC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMV0pICogMikgLyBzaXplWzFdO1xuXG4gIGNvbnN0IGNlbnRlckxuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChjZW50ZXIpO1xuICBjb25zdCB6b29tID0gdmlld3BvcnQuem9vbSArIE1hdGgubG9nMihNYXRoLmFicyhNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpKTtcblxuICByZXR1cm4ge1xuICAgIGxvbmdpdHVkZTogY2VudGVyTG5nTGF0WzBdLFxuICAgIGxhdGl0dWRlOiBjZW50ZXJMbmdMYXRbMV0sXG4gICAgem9vbVxuICB9O1xufVxuIl19