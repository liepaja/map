'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = flyToViewport;

var _math = require('math.gl');

var _mathUtils = require('./math-utils');

var _webMercatorUtils = require('./web-mercator-utils');

var EPSILON = 0.01;
var VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];

/**
 * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.
 * It implements “Smooth and efficient zooming and panning.” algorithm by
 * "Jarke J. van Wijk and Wim A.A. Nuij"
*/
/* eslint-disable max-statements */
function flyToViewport(startProps, endProps, t) {
  // Equations from above paper are referred where needed.

  var viewport = {};

  // TODO: add this as an option for applications.
  var rho = 1.414;

  var startZoom = startProps.zoom;
  var startCenter = [startProps.longitude, startProps.latitude];
  var startScale = (0, _webMercatorUtils.zoomToScale)(startZoom);
  var endZoom = endProps.zoom;
  var endCenter = [endProps.longitude, endProps.latitude];
  var scale = (0, _webMercatorUtils.zoomToScale)(endZoom - startZoom);

  var startCenterXY = new _math.Vector2((0, _webMercatorUtils.lngLatToWorld)(startCenter, startScale));
  var endCenterXY = new _math.Vector2((0, _webMercatorUtils.lngLatToWorld)(endCenter, startScale));
  var uDelta = endCenterXY.subtract(startCenterXY);

  var w0 = Math.max(startProps.width, startProps.height);
  var w1 = w0 / scale;
  var u1 = Math.sqrt(uDelta.x * uDelta.x + uDelta.y * uDelta.y);
  // u0 is treated as '0' in Eq (9).

  // If change in center is too small, do linear interpolaiton.
  if (Math.abs(u1) < EPSILON) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = VIEWPORT_TRANSITION_PROPS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        var startValue = startProps[key];
        var endValue = endProps[key];
        viewport[key] = (0, _mathUtils.lerp)(startValue, endValue, t);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return viewport;
  }

  // Implement Equation (9) from above algorithm.
  var rho2 = rho * rho;
  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);
  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);
  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  var S = (r1 - r0) / rho;
  var s = t * S;

  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;

  var scaleIncrement = 1 / w; // Using w method for scaling.
  var newZoom = startZoom + (0, _webMercatorUtils.scaleToZoom)(scaleIncrement);

  var newCenter = (0, _webMercatorUtils.worldToLngLat)(startCenterXY.add(uDelta.scale(u)).scale(scaleIncrement), (0, _webMercatorUtils.zoomToScale)(newZoom));
  viewport.longitude = newCenter[0];
  viewport.latitude = newCenter[1];
  viewport.zoom = newZoom;
  return viewport;
}
/* eslint-enable max-statements */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mbHktdG8tdmlld3BvcnQuanMiXSwibmFtZXMiOlsiZmx5VG9WaWV3cG9ydCIsIkVQU0lMT04iLCJWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTIiwic3RhcnRQcm9wcyIsImVuZFByb3BzIiwidCIsInZpZXdwb3J0IiwicmhvIiwic3RhcnRab29tIiwiem9vbSIsInN0YXJ0Q2VudGVyIiwibG9uZ2l0dWRlIiwibGF0aXR1ZGUiLCJzdGFydFNjYWxlIiwiZW5kWm9vbSIsImVuZENlbnRlciIsInNjYWxlIiwic3RhcnRDZW50ZXJYWSIsImVuZENlbnRlclhZIiwidURlbHRhIiwic3VidHJhY3QiLCJ3MCIsIk1hdGgiLCJtYXgiLCJ3aWR0aCIsImhlaWdodCIsIncxIiwidTEiLCJzcXJ0IiwieCIsInkiLCJhYnMiLCJrZXkiLCJzdGFydFZhbHVlIiwiZW5kVmFsdWUiLCJyaG8yIiwiYjAiLCJiMSIsInIwIiwibG9nIiwicjEiLCJTIiwicyIsInciLCJjb3NoIiwidSIsInRhbmgiLCJzaW5oIiwic2NhbGVJbmNyZW1lbnQiLCJuZXdab29tIiwibmV3Q2VudGVyIiwiYWRkIl0sIm1hcHBpbmdzIjoiOzs7OztrQkFrQndCQSxhOztBQWxCeEI7O0FBQ0E7O0FBQ0E7O0FBT0EsSUFBTUMsVUFBVSxJQUFoQjtBQUNBLElBQU1DLDRCQUE0QixDQUFDLFdBQUQsRUFBYyxVQUFkLEVBQTBCLE1BQTFCLENBQWxDOztBQUVBOzs7OztBQUtBO0FBQ2UsU0FBU0YsYUFBVCxDQUF1QkcsVUFBdkIsRUFBbUNDLFFBQW5DLEVBQTZDQyxDQUE3QyxFQUFnRDtBQUM3RDs7QUFFQSxNQUFNQyxXQUFXLEVBQWpCOztBQUVBO0FBQ0EsTUFBTUMsTUFBTSxLQUFaOztBQUVBLE1BQU1DLFlBQVlMLFdBQVdNLElBQTdCO0FBQ0EsTUFBTUMsY0FBYyxDQUFDUCxXQUFXUSxTQUFaLEVBQXVCUixXQUFXUyxRQUFsQyxDQUFwQjtBQUNBLE1BQU1DLGFBQWEsbUNBQVlMLFNBQVosQ0FBbkI7QUFDQSxNQUFNTSxVQUFVVixTQUFTSyxJQUF6QjtBQUNBLE1BQU1NLFlBQVksQ0FBQ1gsU0FBU08sU0FBVixFQUFxQlAsU0FBU1EsUUFBOUIsQ0FBbEI7QUFDQSxNQUFNSSxRQUFRLG1DQUFZRixVQUFVTixTQUF0QixDQUFkOztBQUVBLE1BQU1TLGdCQUFnQixrQkFBWSxxQ0FBY1AsV0FBZCxFQUEyQkcsVUFBM0IsQ0FBWixDQUF0QjtBQUNBLE1BQU1LLGNBQWMsa0JBQVkscUNBQWNILFNBQWQsRUFBeUJGLFVBQXpCLENBQVosQ0FBcEI7QUFDQSxNQUFNTSxTQUFTRCxZQUFZRSxRQUFaLENBQXFCSCxhQUFyQixDQUFmOztBQUVBLE1BQU1JLEtBQUtDLEtBQUtDLEdBQUwsQ0FBU3BCLFdBQVdxQixLQUFwQixFQUEyQnJCLFdBQVdzQixNQUF0QyxDQUFYO0FBQ0EsTUFBTUMsS0FBS0wsS0FBS0wsS0FBaEI7QUFDQSxNQUFNVyxLQUFLTCxLQUFLTSxJQUFMLENBQVdULE9BQU9VLENBQVAsR0FBV1YsT0FBT1UsQ0FBbkIsR0FBeUJWLE9BQU9XLENBQVAsR0FBV1gsT0FBT1csQ0FBckQsQ0FBWDtBQUNBOztBQUVBO0FBQ0EsTUFBSVIsS0FBS1MsR0FBTCxDQUFTSixFQUFULElBQWUxQixPQUFuQixFQUE0QjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUMxQiwyQkFBa0JDLHlCQUFsQiw4SEFBNkM7QUFBQSxZQUFsQzhCLEdBQWtDOztBQUMzQyxZQUFNQyxhQUFhOUIsV0FBVzZCLEdBQVgsQ0FBbkI7QUFDQSxZQUFNRSxXQUFXOUIsU0FBUzRCLEdBQVQsQ0FBakI7QUFDQTFCLGlCQUFTMEIsR0FBVCxJQUFnQixxQkFBS0MsVUFBTCxFQUFpQkMsUUFBakIsRUFBMkI3QixDQUEzQixDQUFoQjtBQUNEO0FBTHlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTTFCLFdBQU9DLFFBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQU02QixPQUFPNUIsTUFBTUEsR0FBbkI7QUFDQSxNQUFNNkIsS0FBSyxDQUFDVixLQUFLQSxFQUFMLEdBQVVMLEtBQUtBLEVBQWYsR0FBb0JjLE9BQU9BLElBQVAsR0FBY1IsRUFBZCxHQUFtQkEsRUFBeEMsS0FBK0MsSUFBSU4sRUFBSixHQUFTYyxJQUFULEdBQWdCUixFQUEvRCxDQUFYO0FBQ0EsTUFBTVUsS0FBSyxDQUFDWCxLQUFLQSxFQUFMLEdBQVVMLEtBQUtBLEVBQWYsR0FBb0JjLE9BQU9BLElBQVAsR0FBY1IsRUFBZCxHQUFtQkEsRUFBeEMsS0FBK0MsSUFBSUQsRUFBSixHQUFTUyxJQUFULEdBQWdCUixFQUEvRCxDQUFYO0FBQ0EsTUFBTVcsS0FBS2hCLEtBQUtpQixHQUFMLENBQVNqQixLQUFLTSxJQUFMLENBQVVRLEtBQUtBLEVBQUwsR0FBVSxDQUFwQixJQUF5QkEsRUFBbEMsQ0FBWDtBQUNBLE1BQU1JLEtBQUtsQixLQUFLaUIsR0FBTCxDQUFTakIsS0FBS00sSUFBTCxDQUFVUyxLQUFLQSxFQUFMLEdBQVUsQ0FBcEIsSUFBeUJBLEVBQWxDLENBQVg7QUFDQSxNQUFNSSxJQUFJLENBQUNELEtBQUtGLEVBQU4sSUFBWS9CLEdBQXRCO0FBQ0EsTUFBTW1DLElBQUlyQyxJQUFJb0MsQ0FBZDs7QUFFQSxNQUFNRSxJQUFLckIsS0FBS3NCLElBQUwsQ0FBVU4sRUFBVixJQUFnQmhCLEtBQUtzQixJQUFMLENBQVVOLEtBQUsvQixNQUFNbUMsQ0FBckIsQ0FBM0I7QUFDQSxNQUFNRyxJQUFJeEIsTUFBTSxDQUFDQyxLQUFLc0IsSUFBTCxDQUFVTixFQUFWLElBQWdCaEIsS0FBS3dCLElBQUwsQ0FBVVIsS0FBSy9CLE1BQU1tQyxDQUFyQixDQUFoQixHQUEwQ3BCLEtBQUt5QixJQUFMLENBQVVULEVBQVYsQ0FBM0MsSUFBNERILElBQWxFLElBQTBFUixFQUFwRjs7QUFFQSxNQUFNcUIsaUJBQWlCLElBQUlMLENBQTNCLENBOUM2RCxDQThDL0I7QUFDOUIsTUFBTU0sVUFBVXpDLFlBQVksbUNBQVl3QyxjQUFaLENBQTVCOztBQUVBLE1BQU1FLFlBQVkscUNBQ2ZqQyxjQUFja0MsR0FBZCxDQUFrQmhDLE9BQU9ILEtBQVAsQ0FBYTZCLENBQWIsQ0FBbEIsQ0FBRCxDQUFxQzdCLEtBQXJDLENBQTJDZ0MsY0FBM0MsQ0FEZ0IsRUFFaEIsbUNBQVlDLE9BQVosQ0FGZ0IsQ0FBbEI7QUFHQTNDLFdBQVNLLFNBQVQsR0FBcUJ1QyxVQUFVLENBQVYsQ0FBckI7QUFDQTVDLFdBQVNNLFFBQVQsR0FBb0JzQyxVQUFVLENBQVYsQ0FBcEI7QUFDQTVDLFdBQVNHLElBQVQsR0FBZ0J3QyxPQUFoQjtBQUNBLFNBQU8zQyxRQUFQO0FBQ0Q7QUFDRCIsImZpbGUiOiJmbHktdG8tdmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1ZlY3RvcjJ9IGZyb20gJ21hdGguZ2wnO1xuaW1wb3J0IHtsZXJwfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuaW1wb3J0IHtcbiAgc2NhbGVUb1pvb20sXG4gIHpvb21Ub1NjYWxlLFxuICBsbmdMYXRUb1dvcmxkLFxuICB3b3JsZFRvTG5nTGF0XG59IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcblxuY29uc3QgRVBTSUxPTiA9IDAuMDE7XG5jb25zdCBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTID0gWydsb25naXR1ZGUnLCAnbGF0aXR1ZGUnLCAnem9vbSddO1xuXG4vKipcbiAqIG1hcGJveC1nbC1qcyBmbHlUbyA6IGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jbWFwI2ZseXRvLlxuICogSXQgaW1wbGVtZW50cyDigJxTbW9vdGggYW5kIGVmZmljaWVudCB6b29taW5nIGFuZCBwYW5uaW5nLuKAnSBhbGdvcml0aG0gYnlcbiAqIFwiSmFya2UgSi4gdmFuIFdpamsgYW5kIFdpbSBBLkEuIE51aWpcIlxuKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmbHlUb1ZpZXdwb3J0KHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KSB7XG4gIC8vIEVxdWF0aW9ucyBmcm9tIGFib3ZlIHBhcGVyIGFyZSByZWZlcnJlZCB3aGVyZSBuZWVkZWQuXG5cbiAgY29uc3Qgdmlld3BvcnQgPSB7fTtcblxuICAvLyBUT0RPOiBhZGQgdGhpcyBhcyBhbiBvcHRpb24gZm9yIGFwcGxpY2F0aW9ucy5cbiAgY29uc3QgcmhvID0gMS40MTQ7XG5cbiAgY29uc3Qgc3RhcnRab29tID0gc3RhcnRQcm9wcy56b29tO1xuICBjb25zdCBzdGFydENlbnRlciA9IFtzdGFydFByb3BzLmxvbmdpdHVkZSwgc3RhcnRQcm9wcy5sYXRpdHVkZV07XG4gIGNvbnN0IHN0YXJ0U2NhbGUgPSB6b29tVG9TY2FsZShzdGFydFpvb20pO1xuICBjb25zdCBlbmRab29tID0gZW5kUHJvcHMuem9vbTtcbiAgY29uc3QgZW5kQ2VudGVyID0gW2VuZFByb3BzLmxvbmdpdHVkZSwgZW5kUHJvcHMubGF0aXR1ZGVdO1xuICBjb25zdCBzY2FsZSA9IHpvb21Ub1NjYWxlKGVuZFpvb20gLSBzdGFydFpvb20pO1xuXG4gIGNvbnN0IHN0YXJ0Q2VudGVyWFkgPSBuZXcgVmVjdG9yMihsbmdMYXRUb1dvcmxkKHN0YXJ0Q2VudGVyLCBzdGFydFNjYWxlKSk7XG4gIGNvbnN0IGVuZENlbnRlclhZID0gbmV3IFZlY3RvcjIobG5nTGF0VG9Xb3JsZChlbmRDZW50ZXIsIHN0YXJ0U2NhbGUpKTtcbiAgY29uc3QgdURlbHRhID0gZW5kQ2VudGVyWFkuc3VidHJhY3Qoc3RhcnRDZW50ZXJYWSk7XG5cbiAgY29uc3QgdzAgPSBNYXRoLm1heChzdGFydFByb3BzLndpZHRoLCBzdGFydFByb3BzLmhlaWdodCk7XG4gIGNvbnN0IHcxID0gdzAgLyBzY2FsZTtcbiAgY29uc3QgdTEgPSBNYXRoLnNxcnQoKHVEZWx0YS54ICogdURlbHRhLngpICsgKHVEZWx0YS55ICogdURlbHRhLnkpKTtcbiAgLy8gdTAgaXMgdHJlYXRlZCBhcyAnMCcgaW4gRXEgKDkpLlxuXG4gIC8vIElmIGNoYW5nZSBpbiBjZW50ZXIgaXMgdG9vIHNtYWxsLCBkbyBsaW5lYXIgaW50ZXJwb2xhaXRvbi5cbiAgaWYgKE1hdGguYWJzKHUxKSA8IEVQU0lMT04pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTKSB7XG4gICAgICBjb25zdCBzdGFydFZhbHVlID0gc3RhcnRQcm9wc1trZXldO1xuICAgICAgY29uc3QgZW5kVmFsdWUgPSBlbmRQcm9wc1trZXldO1xuICAgICAgdmlld3BvcnRba2V5XSA9IGxlcnAoc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld3BvcnQ7XG4gIH1cblxuICAvLyBJbXBsZW1lbnQgRXF1YXRpb24gKDkpIGZyb20gYWJvdmUgYWxnb3JpdGhtLlxuICBjb25zdCByaG8yID0gcmhvICogcmhvO1xuICBjb25zdCBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzIgKiByaG8yICogdTEgKiB1MSkgLyAoMiAqIHcwICogcmhvMiAqIHUxKTtcbiAgY29uc3QgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSByaG8yICogcmhvMiAqIHUxICogdTEpIC8gKDIgKiB3MSAqIHJobzIgKiB1MSk7XG4gIGNvbnN0IHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKTtcbiAgY29uc3QgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICBjb25zdCBTID0gKHIxIC0gcjApIC8gcmhvO1xuICBjb25zdCBzID0gdCAqIFM7XG5cbiAgY29uc3QgdyA9IChNYXRoLmNvc2gocjApIC8gTWF0aC5jb3NoKHIwICsgcmhvICogcykpO1xuICBjb25zdCB1ID0gdzAgKiAoKE1hdGguY29zaChyMCkgKiBNYXRoLnRhbmgocjAgKyByaG8gKiBzKSAtIE1hdGguc2luaChyMCkpIC8gcmhvMikgLyB1MTtcblxuICBjb25zdCBzY2FsZUluY3JlbWVudCA9IDEgLyB3OyAvLyBVc2luZyB3IG1ldGhvZCBmb3Igc2NhbGluZy5cbiAgY29uc3QgbmV3Wm9vbSA9IHN0YXJ0Wm9vbSArIHNjYWxlVG9ab29tKHNjYWxlSW5jcmVtZW50KTtcblxuICBjb25zdCBuZXdDZW50ZXIgPSB3b3JsZFRvTG5nTGF0KFxuICAgIChzdGFydENlbnRlclhZLmFkZCh1RGVsdGEuc2NhbGUodSkpKS5zY2FsZShzY2FsZUluY3JlbWVudCksXG4gICAgem9vbVRvU2NhbGUobmV3Wm9vbSkpO1xuICB2aWV3cG9ydC5sb25naXR1ZGUgPSBuZXdDZW50ZXJbMF07XG4gIHZpZXdwb3J0LmxhdGl0dWRlID0gbmV3Q2VudGVyWzFdO1xuICB2aWV3cG9ydC56b29tID0gbmV3Wm9vbTtcbiAgcmV0dXJuIHZpZXdwb3J0O1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuIl19