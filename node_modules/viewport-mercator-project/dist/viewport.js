'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // View and Projection Matrix management

/* eslint-disable camelcase */


var _math = require('math.gl');

var _mathUtils = require('./math-utils');

var _webMercatorUtils = require('./web-mercator-utils');

var _scale = require('gl-mat4/scale');

var _scale2 = _interopRequireDefault(_scale);

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _multiply = require('gl-mat4/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _invert = require('gl-mat4/invert');

var _invert2 = _interopRequireDefault(_invert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IDENTITY = (0, _mathUtils.createMat4)();

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix;

    _classCallCheck(this, Viewport);

    // Silently allow apps to send in 0,0
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;

    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;

    // Note: As usual, matrix operations should be applied in "reverse" order
    // since vectors will be multiplied in from the right during transformation
    var vpm = (0, _mathUtils.createMat4)();
    (0, _multiply2.default)(vpm, vpm, this.projectionMatrix);
    (0, _multiply2.default)(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;

    // Calculate matrices and scales needed for projection
    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */
    var m = (0, _mathUtils.createMat4)();

    // matrix for conversion from location to screen coordinates
    (0, _scale2.default)(m, m, [this.width / 2, -this.height / 2, 1]);
    (0, _translate2.default)(m, m, [1, -1, 0]);

    (0, _multiply2.default)(m, m, this.viewProjectionMatrix);

    var mInverse = (0, _invert2.default)((0, _mathUtils.createMat4)(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;

    // Bind methods for easy access
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  /* eslint-enable complexity */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix);
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - screen coordinates [x, y] or [x, y, z], z as pixel depth
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? true : _ref2$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          z0 = _xyz[2];

      var _projectFlat = this.projectFlat([x0, y0]),
          _projectFlat2 = _slicedToArray(_projectFlat, 2),
          X = _projectFlat2[0],
          Y = _projectFlat2[1];

      var coord = (0, _webMercatorUtils.worldToPixels)([X, Y, z0], this.pixelProjectionMatrix);

      var _coord = _slicedToArray(coord, 2),
          x = _coord[0],
          y = _coord[1];

      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz - screen coordinates, z as pixel depth
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @param {Object} opts.targetZ=0 - If pixel depth is unknown, targetZ is used as
     *   the elevation plane to unproject onto
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === undefined ? true : _ref3$topLeft,
          targetZ = _ref3.targetZ;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          z = _xyz2[2];

      var y2 = topLeft ? y : this.height - y;
      var coord = (0, _webMercatorUtils.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZ);

      var _unprojectFlat = this.unprojectFlat(coord),
          _unprojectFlat2 = _slicedToArray(_unprojectFlat, 2),
          X = _unprojectFlat2[0],
          Y = _unprojectFlat2[1];

      if (Number.isFinite(z)) {
        // Has depth component
        return [X, Y, coord[2]];
      }

      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project map coordinates to world coordinates.
     * This should be overridden by each viewport that implements a specific
     * geographic projection.
     * @param {Array} xyz - map coordinates
     * @return {Array} [x,y,z] world coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }

    /**
     * Project world coordinates to map coordinates.
     * This should be overridden by each viewport that implements a specific
     * geographic projection.
     * @param {Array} xyz - world coordinates
     * @return {Array} [x,y,z] map coordinates.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }]);

  return Viewport;
}();

exports.default = Viewport;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJJREVOVElUWSIsIlZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsInNjYWxlIiwidnBtIiwidmlld1Byb2plY3Rpb25NYXRyaXgiLCJtIiwibUludmVyc2UiLCJFcnJvciIsInBpeGVsUHJvamVjdGlvbk1hdHJpeCIsInBpeGVsVW5wcm9qZWN0aW9uTWF0cml4IiwiZXF1YWxzIiwiYmluZCIsInByb2plY3QiLCJ1bnByb2plY3QiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJ2aWV3cG9ydCIsInh5eiIsInRvcExlZnQiLCJ4MCIsInkwIiwiejAiLCJYIiwiWSIsImNvb3JkIiwieCIsInkiLCJ5MiIsImxlbmd0aCIsInRhcmdldFoiLCJ6IiwiTnVtYmVyIiwiaXNGaW5pdGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O3FqQkFBQTs7QUFFQTs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBTUEsV0FBVyw0QkFBakI7O0lBRXFCQyxRO0FBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0Esc0JBT1E7QUFBQSxtRkFBSixFQUFJO0FBQUEsUUFMTkMsS0FLTSxRQUxOQSxLQUtNO0FBQUEsUUFKTkMsTUFJTSxRQUpOQSxNQUlNO0FBQUEsK0JBRk5DLFVBRU07QUFBQSxRQUZOQSxVQUVNLG1DQUZPSixRQUVQO0FBQUEscUNBRE5LLGdCQUNNO0FBQUEsUUFETkEsZ0JBQ00seUNBRGFMLFFBQ2I7O0FBQUE7O0FBQ047QUFDQSxTQUFLRSxLQUFMLEdBQWFBLFNBQVMsQ0FBdEI7QUFDQSxTQUFLQyxNQUFMLEdBQWNBLFVBQVUsQ0FBeEI7QUFDQSxTQUFLRyxLQUFMLEdBQWEsQ0FBYjs7QUFFQSxTQUFLRixVQUFMLEdBQWtCQSxVQUFsQjtBQUNBLFNBQUtDLGdCQUFM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QUFPZSxHQUFQO0FBQ0Q7Ozs7OztrQkEzS2tCcEIsUSIsImZpbGUiOiJ2aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IG1hbmFnZW1lbnRcblxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5pbXBvcnQge2VxdWFsc30gZnJvbSAnbWF0aC5nbCc7XG5pbXBvcnQge2NyZWF0ZU1hdDR9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQge3dvcmxkVG9QaXhlbHMsIHBpeGVsc1RvV29ybGR9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcblxuaW1wb3J0IG1hdDRfc2NhbGUgZnJvbSAnZ2wtbWF0NC9zY2FsZSc7XG5pbXBvcnQgbWF0NF90cmFuc2xhdGUgZnJvbSAnZ2wtbWF0NC90cmFuc2xhdGUnO1xuaW1wb3J0IG1hdDRfbXVsdGlwbHkgZnJvbSAnZ2wtbWF0NC9tdWx0aXBseSc7XG5pbXBvcnQgbWF0NF9pbnZlcnQgZnJvbSAnZ2wtbWF0NC9pbnZlcnQnO1xuXG5jb25zdCBJREVOVElUWSA9IGNyZWF0ZU1hdDQoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBNYW5hZ2VzIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjay5nbC5cbiAgICpcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIFdpbmRvdyB3aWR0aC9oZWlnaHQgaW4gcGl4ZWxzIChmb3IgcGl4ZWwgcHJvamVjdGlvbilcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgLy8gRGVzY1xuICAgIHZpZXdNYXRyaXggPSBJREVOVElUWSxcbiAgICBwcm9qZWN0aW9uTWF0cml4ID0gSURFTlRJVFlcbiAgfSA9IHt9KSB7XG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMFxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgdGhpcy5zY2FsZSA9IDE7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXggPSB2aWV3TWF0cml4O1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgaW4gXCJyZXZlcnNlXCIgb3JkZXJcbiAgICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBpbiBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NF9tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0X211bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG5cbiAgICAvLyBDYWxjdWxhdGUgbWF0cmljZXMgYW5kIHNjYWxlcyBuZWVkZWQgZm9yIHByb2plY3Rpb25cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgbWF0cmljZXMgdGhhdCBjb252ZXJ0cyBwcmVwcm9qZWN0ZWQgbG5nTGF0cyB0byBzY3JlZW4gcGl4ZWxzXG4gICAgICogYW5kIHZpY2UgdmVyc2EuXG4gICAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAgICogTm90ZTogU3RhcnRzIHdpdGggdGhlIEdMIHByb2plY3Rpb24gbWF0cml4IGFuZCBhZGRzIHN0ZXBzIHRvIHRoZVxuICAgICAqICAgICAgIHNjYWxlIGFuZCB0cmFuc2xhdGUgdGhhdCBtYXRyaXggb250byB0aGUgd2luZG93LlxuICAgICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgICAqICAgICAgIGFuZCBkb2VzIG5vdCBuZWVkIHRoaXMgc3RlcC5cbiAgICAgKi9cbiAgICBjb25zdCBtID0gY3JlYXRlTWF0NCgpO1xuXG4gICAgLy8gbWF0cml4IGZvciBjb252ZXJzaW9uIGZyb20gbG9jYXRpb24gdG8gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgbWF0NF9zY2FsZShtLCBtLCBbdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIsIDFdKTtcbiAgICBtYXQ0X3RyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcblxuICAgIG1hdDRfbXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICBjb25zdCBtSW52ZXJzZSA9IG1hdDRfaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgbSk7XG4gICAgaWYgKCFtSW52ZXJzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgIH1cblxuICAgIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbTtcbiAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbUludmVyc2U7XG5cbiAgICAvLyBCaW5kIG1ldGhvZHMgZm9yIGVhc3kgYWNjZXNzXG4gICAgdGhpcy5lcXVhbHMgPSB0aGlzLmVxdWFscy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvamVjdCA9IHRoaXMucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0ID0gdGhpcy51bnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2plY3RGbGF0ID0gdGhpcy5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0RmxhdCA9IHRoaXMudW5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIC8vIFR3byB2aWV3cG9ydHMgYXJlIGVxdWFsIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGlkZW50aWNhbCwgYW5kIGlmXG4gIC8vIHRoZWlyIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cmljZXMgYXJlIChhcHByb3hpbWF0ZWx5KSBlcXVhbC5cbiAgZXF1YWxzKHZpZXdwb3J0KSB7XG4gICAgaWYgKCEodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlld3BvcnQud2lkdGggPT09IHRoaXMud2lkdGggJiZcbiAgICAgIHZpZXdwb3J0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgIGVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmXG4gICAgICBlcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0cyB4eXogKHBvc3NpYmx5IGxhdGl0dWRlIGFuZCBsb25naXR1ZGUpIHRvIHBpeGVsIGNvb3JkaW5hdGVzIGluIHdpbmRvd1xuICAgKiB1c2luZyB2aWV3cG9ydCBwcm9qZWN0aW9uIHBhcmFtZXRlcnNcbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gW3gsIHldXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIFpdID0+IFt4LCB5LCB6XVxuICAgKiBOb3RlOiBCeSBkZWZhdWx0LCByZXR1cm5zIHRvcC1sZWZ0IGNvb3JkaW5hdGVzIGZvciBjYW52YXMvU1ZHIHR5cGUgcmVuZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdFogLSBbbG5nLCBsYXRdIG9yIFtsbmcsIGxhdCwgWl1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnRvcExlZnQ9dHJ1ZSAtIFdoZXRoZXIgcHJvamVjdGVkIGNvb3JkcyBhcmUgdG9wIGxlZnRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gc2NyZWVuIGNvb3JkaW5hdGVzIFt4LCB5XSBvciBbeCwgeSwgel0sIHogYXMgcGl4ZWwgZGVwdGhcbiAgICovXG4gIHByb2plY3QoeHl6LCB7dG9wTGVmdCA9IHRydWV9ID0ge30pIHtcbiAgICBjb25zdCBbeDAsIHkwLCB6MF0gPSB4eXo7XG5cbiAgICBjb25zdCBbWCwgWV0gPSB0aGlzLnByb2plY3RGbGF0KFt4MCwgeTBdKTtcbiAgICBjb25zdCBjb29yZCA9IHdvcmxkVG9QaXhlbHMoW1gsIFksIHowXSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgY29uc3QgW3gsIHldID0gY29vcmQ7XG4gICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8geSA6IHRoaXMuaGVpZ2h0IC0geTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFt4LCB5Ml0gOiBbeCwgeTIsIGNvb3JkWzJdXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gd29ybGQgY29vcmRpbmF0ZXMsXG4gICAqIChwb3NzaWJseSBbbG9uLCBsYXRdKSBvbiBtYXAuXG4gICAqIC0gW3gsIHldID0+IFtsbmcsIGxhdF1cbiAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge0FycmF5fSB4eXogLSBzY3JlZW4gY29vcmRpbmF0ZXMsIHogYXMgcGl4ZWwgZGVwdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnRvcExlZnQ9dHJ1ZSAtIFdoZXRoZXIgcHJvamVjdGVkIGNvb3JkcyBhcmUgdG9wIGxlZnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudGFyZ2V0Wj0wIC0gSWYgcGl4ZWwgZGVwdGggaXMgdW5rbm93biwgdGFyZ2V0WiBpcyB1c2VkIGFzXG4gICAqICAgdGhlIGVsZXZhdGlvbiBwbGFuZSB0byB1bnByb2plY3Qgb250b1xuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbbG5nLCBsYXQsIFpdIG9yIFtYLCBZLCBaXVxuICAgKi9cbiAgdW5wcm9qZWN0KHh5eiwge3RvcExlZnQgPSB0cnVlLCB0YXJnZXRafSA9IHt9KSB7XG4gICAgY29uc3QgW3gsIHksIHpdID0geHl6O1xuXG4gICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8geSA6IHRoaXMuaGVpZ2h0IC0geTtcbiAgICBjb25zdCBjb29yZCA9IHBpeGVsc1RvV29ybGQoW3gsIHkyLCB6XSwgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCwgdGFyZ2V0Wik7XG4gICAgY29uc3QgW1gsIFldID0gdGhpcy51bnByb2plY3RGbGF0KGNvb3JkKTtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoeikpIHtcbiAgICAgIC8vIEhhcyBkZXB0aCBjb21wb25lbnRcbiAgICAgIHJldHVybiBbWCwgWSwgY29vcmRbMl1dO1xuICAgIH1cblxuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodGFyZ2V0WikgPyBbWCwgWSwgdGFyZ2V0Wl0gOiBbWCwgWV07XG4gIH1cblxuICAvLyBOT05fTElORUFSIFBST0pFQ1RJT04gSE9PS1NcbiAgLy8gVXNlZCBmb3Igd2ViIG1lcmFjdG9yIHByb2plY3Rpb25cblxuICAvKipcbiAgICogUHJvamVjdCBtYXAgY29vcmRpbmF0ZXMgdG8gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAqIFRoaXMgc2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgZWFjaCB2aWV3cG9ydCB0aGF0IGltcGxlbWVudHMgYSBzcGVjaWZpY1xuICAgKiBnZW9ncmFwaGljIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtIG1hcCBjb29yZGluYXRlc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseSx6XSB3b3JsZCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHh5ejtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0IHdvcmxkIGNvb3JkaW5hdGVzIHRvIG1hcCBjb29yZGluYXRlcy5cbiAgICogVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBlYWNoIHZpZXdwb3J0IHRoYXQgaW1wbGVtZW50cyBhIHNwZWNpZmljXG4gICAqIGdlb2dyYXBoaWMgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheX0geHl6IC0gd29ybGQgY29vcmRpbmF0ZXNcbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHksel0gbWFwIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB4eXo7XG4gIH1cblxufVxuIl19