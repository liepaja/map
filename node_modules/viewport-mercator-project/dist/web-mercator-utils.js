'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); // TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE

exports.zoomToScale = zoomToScale;
exports.scaleToZoom = scaleToZoom;
exports.lngLatToWorld = lngLatToWorld;
exports.worldToLngLat = worldToLngLat;
exports.getMeterZoom = getMeterZoom;
exports.getDistanceScales = getDistanceScales;
exports.getWorldPosition = getWorldPosition;
exports.getViewMatrix = getViewMatrix;
exports.getProjectionMatrix = getProjectionMatrix;
exports.worldToPixels = worldToPixels;
exports.pixelsToWorld = pixelsToWorld;

var _math = require('math.gl');

var _mathUtils = require('./math-utils');

var _perspective = require('gl-mat4/perspective');

var _perspective2 = _interopRequireDefault(_perspective);

var _scale = require('gl-mat4/scale');

var _scale2 = _interopRequireDefault(_scale);

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _rotateX = require('gl-mat4/rotateX');

var _rotateX2 = _interopRequireDefault(_rotateX);

var _rotateZ = require('gl-mat4/rotateZ');

var _rotateZ2 = _interopRequireDefault(_rotateZ);

var _lerp = require('gl-vec2/lerp');

var _lerp2 = _interopRequireDefault(_lerp);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
// Average circumference (40075 km equatorial, 40007 km meridional)
var EARTH_CIRCUMFERENCE = 40.03e6;

/** Util functions **/
function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}

function scaleToZoom(scale) {
  return Math.log2(scale);
}

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */
function lngLatToWorld(_ref, scale) {
  var _ref2 = _slicedToArray(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  scale *= TILE_SIZE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function worldToLngLat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale *= TILE_SIZE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

// Returns the zoom level that gives a 1 meter pixel at a certain latitude
// S=C*cos(y)/2^(z+8)
function getMeterZoom(_ref5) {
  var latitude = _ref5.latitude;

  (0, _assert2.default)(Number.isFinite(latitude));
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 8;
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function getDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      zoom = _ref6.zoom,
      scale = _ref6.scale,
      _ref6$highPrecision = _ref6.highPrecision,
      highPrecision = _ref6$highPrecision === undefined ? false : _ref6$highPrecision;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : zoomToScale(zoom);

  (0, _assert2.default)(Number.isFinite(latitude) && Number.isFinite(longitude) && Number.isFinite(scale));

  var result = {};
  var worldSize = TILE_SIZE * scale;
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);

  /**
   * Number of pixels occupied by one degree longitude around current lat/lon:
     pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
       = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
     pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
       = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
   */
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;

  /**
   * Number of pixels occupied by one meter around current lat/lon:
   */
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;

  result.pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / altPixelsPerMeter];

  result.pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  /**
   * Taylor series 2nd order for 1/latCosine
     f'(a) * (x - a)
       = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
       = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
   */
  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;

    result.pixelsPerDegree2 = [0, pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
  }

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return result;
}

/**
 * Calculates a mercator world position ("pixels" in given zoom level)
 * from a lng/lat and meterOffset
 */
function getWorldPosition(_ref7) {
  var longitude = _ref7.longitude,
      latitude = _ref7.latitude,
      zoom = _ref7.zoom,
      scale = _ref7.scale,
      meterOffset = _ref7.meterOffset,
      _ref7$distanceScales = _ref7.distanceScales,
      distanceScales = _ref7$distanceScales === undefined ? null : _ref7$distanceScales;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : zoomToScale(zoom);

  // Make a centered version of the matrix for projection modes without an offset
  var center2d = lngLatToWorld([longitude, latitude], scale);
  var center = new _math.Vector3(center2d[0], center2d[1], 0);

  if (meterOffset) {
    // Calculate distance scales if lng/lat/zoom are provided
    distanceScales = distanceScales || getDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var pixelPosition = new _math.Vector3(meterOffset)
    // Convert to pixels in current zoom
    .scale(distanceScales.pixelsPerMeter)
    // We want positive Y to represent an offset towards north,
    // but web mercator world coordinates is top-left
    .scale([1, -1, 1]);
    center.add(pixelPosition);
  }

  return center;
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

function getViewMatrix(_ref10) {
  var height = _ref10.height,
      pitch = _ref10.pitch,
      bearing = _ref10.bearing,
      altitude = _ref10.altitude,
      _ref10$center = _ref10.center,
      center = _ref10$center === undefined ? null : _ref10$center,
      _ref10$flipY = _ref10.flipY,
      flipY = _ref10$flipY === undefined ? false : _ref10$flipY;


  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
  // Note that mercator world coordinates typically need to be flipped
  //
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = (0, _mathUtils.createMat4)();

  // Move camera to altitude (along the pitch & bearing direction)
  (0, _translate2.default)(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  (0, _scale2.default)(vm, vm, [1, 1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  (0, _rotateX2.default)(vm, vm, -pitch * DEGREES_TO_RADIANS);
  (0, _rotateZ2.default)(vm, vm, bearing * DEGREES_TO_RADIANS);

  if (flipY) {
    (0, _scale2.default)(vm, vm, [1, -1, 1]);
  }

  if (center) {
    (0, _translate2.default)(vm, vm, new _math.Vector3(center).negate());
  }

  return vm;
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
// This is a "Mapbox" projection matrix - matches mapbox exactly if farZMultiplier === 1
function getProjectionMatrix(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      pitch = _ref11.pitch,
      altitude = _ref11.altitude,
      _ref11$farZMultiplier = _ref11.farZMultiplier,
      farZMultiplier = _ref11$farZMultiplier === undefined ? 10 : _ref11$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = (0, _perspective2.default)([], fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

/**
 * Project flat coordinates to pixels on screen.
 *
 * @param {Array} xyz - flat coordinate on 512*512 Mercator Zoom 0 tile
 * @param {Matrix4} pixelProjectionMatrix - projection matrix
 * @return {Array} [x, y, depth] pixel coordinate on screen.
 */
function worldToPixels(xyz, pixelProjectionMatrix) {
  var _xyz = _slicedToArray(xyz, 3),
      x = _xyz[0],
      y = _xyz[1],
      _xyz$ = _xyz[2],
      z = _xyz$ === undefined ? 0 : _xyz$;

  (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));

  return (0, _mathUtils.transformVector)(pixelProjectionMatrix, [x, y, z, 1]);
}

/**
 * Unproject pixels on screen to flat coordinates.
 *
 * @param {Array} xyz - pixel coordinate on screen.
 * @param {Matrix4} pixelUnprojectionMatrix - unprojection matrix
 * @param {Number} targetZ - if pixel coordinate does not have a 3rd component (depth),
 *    targetZ is used as the elevation plane to unproject onto
 * @return {Array} [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.
 */
function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var _xyz2 = _slicedToArray(xyz, 3),
      x = _xyz2[0],
      y = _xyz2[1],
      z = _xyz2[2];

  (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y));

  if (Number.isFinite(z)) {
    // Has depth component
    var coord = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }

  // since we don't know the correct projected z value for the point,
  // unproject two points to get a line and then find the point on that line with z=0
  var coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 0, 1]);
  var coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 1, 1]);

  var z0 = coord0[2];
  var z1 = coord1[2];

  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return (0, _lerp2.default)([], coord0, coord1, t);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3ItdXRpbHMuanMiXSwibmFtZXMiOlsiem9vbVRvU2NhbGUiLCJzY2FsZVRvWm9vbSIsImxuZ0xhdFRvV29ybGQiLCJ3b3JsZFRvTG5nTGF0IiwiZ2V0TWV0ZXJab29tIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJnZXRXb3JsZFBvc2l0aW9uIiwiZ2V0Vmlld01hdHJpeCIsImdldFByb2plY3Rpb25NYXRyaXgiLCJ3b3JsZFRvUGl4ZWxzIiwicGl4ZWxzVG9Xb3JsZCIsIlBJIiwiTWF0aCIsIlBJXzQiLCJERUdSRUVTX1RPX1JBRElBTlMiLCJSQURJQU5TX1RPX0RFR1JFRVMiLCJUSUxFX1NJWkUiLCJFQVJUSF9DSVJDVU1GRVJFTkNFIiwiem9vbSIsInBvdyIsInNjYWxlIiwibG9nMiIsImxuZyIsImxhdCIsImxhbWJkYTIiLCJwaGkyIiwieCIsInkiLCJsb2ciLCJ0YW4iLCJhdGFuIiwiZXhwIiwibGF0aXR1ZGUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImxhdENvc2luZSIsImNvcyIsImxvbmdpdHVkZSIsImhpZ2hQcmVjaXNpb24iLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJ3b3JsZFNpemUiLCJwaXhlbHNQZXJEZWdyZWVYIiwicGl4ZWxzUGVyRGVncmVlWSIsImFsdFBpeGVsc1Blck1ldGVyIiwicGl4ZWxzUGVyTWV0ZXIiLCJtZXRlcnNQZXJQaXhlbCIsInBpeGVsc1BlckRlZ3JlZSIsImRlZ3JlZXNQZXJQaXhlbCIsImxhdENvc2luZTIiLCJwaXhlbHNQZXJEZWdyZWVZMiIsImFsdFBpeGVsc1BlckRlZ3JlZTIiLCJhbHRQaXhlbHNQZXJNZXRlcjIiLCJwaXhlbHNQZXJEZWdyZWUyIiwicGl4ZWxzUGVyTWV0ZXIyIiwibWV0ZXJPZmZzZXQiLCJkaXN0YW5jZVNjYWxlcyIsImNlbnRlcjJkIiwiY2VudGVyIiwicGl4ZWxQb3NpdGlvbiIsImFkZCIsImdldEZvdiIsImhlaWdodCIsImFsdGl0dWRlIiwiZ2V0Q2xpcHBpbmdQbGFuZXMiLCJwaXRjaCIsInBpdGNoUmFkaWFucyIsImhhbGZGb3YiLCJ0b3BIYWxmU3VyZmFjZURpc3RhbmNlIiwic2luIiwiZmFyWiIsIm5lYXJaIiwiYmVhcmluZyIsImZsaXBZIiwidm0iLCJuZWdhdGUiLCJ3aWR0aCIsImZhclpNdWx0aXBsaWVyIiwiZm92IiwicHJvamVjdGlvbk1hdHJpeCIsInh5eiIsInBpeGVsUHJvamVjdGlvbk1hdHJpeCIsInoiLCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeCIsInRhcmdldFoiLCJjb29yZCIsImNvb3JkMCIsImNvb3JkMSIsInowIiwiejEiLCJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7eXBCQUFBOztRQXVCZ0JBLFcsR0FBQUEsVztRQUlBQyxXLEdBQUFBLFc7UUFjQUMsYSxHQUFBQSxhO1FBa0JBQyxhLEdBQUFBLGE7UUFTQUMsWSxHQUFBQSxZO1FBWUFDLGlCLEdBQUFBLGlCO1FBdURBQyxnQixHQUFBQSxnQjtRQXVEQUMsYSxHQUFBQSxhO1FBMkNBQyxtQixHQUFBQSxtQjtRQTRCQUMsYSxHQUFBQSxhO1FBZ0JBQyxhLEdBQUFBLGE7O0FBblJoQjs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7QUFDQSxJQUFNQyxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0E7QUFDQSxJQUFNQyxzQkFBc0IsT0FBNUI7O0FBRUE7QUFDTyxTQUFTakIsV0FBVCxDQUFxQmtCLElBQXJCLEVBQTJCO0FBQ2hDLFNBQU9OLEtBQUtPLEdBQUwsQ0FBUyxDQUFULEVBQVlELElBQVosQ0FBUDtBQUNEOztBQUVNLFNBQVNqQixXQUFULENBQXFCbUIsS0FBckIsRUFBNEI7QUFDakMsU0FBT1IsS0FBS1MsSUFBTCxD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LFNBQVN4RSxhQUFULENBQXVCc0UsR0FBdkIsRUFBNEJHLHVCQUE1QixFQUFrRTtBQUFBLE1BQWJDLE9BQWEsdUVBQUgsQ0FBRzs7QUFBQSw2QkFDckRKLEdBRHFEO0FBQUEsTUFDaEV0RCxDQURnRTtBQUFBLE1BQzdEQyxDQUQ2RDtBQUFBLE1BQzFEdUQsQ0FEMEQ7O0FBRXZFLHdCQUFPakQsT0FBT0MsUUFBUCxDQUFnQlIsQ0FBaEIsS0FBc0JPLE9BQU9DLFFBQVAsQ0FBZ0JQLENBQWhCLENBQTdCOztBQUVBLE1BQUlNLE9BQU9DLFFBQVAsQ0FBZ0JnRCxDQUFoQixDQUFKLEVBQXdCO0FBQ3RCO0FBQ0EsUUFBTUcsUUFBUSxnQ0FBZ0JGLHVCQUFoQixFQUF5QyxDQUFDekQsQ0FBRCxFQUFJQyxDQUFKLEVBQU91RCxDQUFQLEVBQVUsQ0FBVixDQUF6QyxDQUFkO0FBQ0EsV0FBT0csS0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxNQUFNQyxTQUFTLGdDQUFnQkgsdUJBQWhCLEVBQXlDLENBQUN6RCxDQUFELEVBQUlDLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUF6QyxDQUFmO0FBQ0EsTUFBTTRELFNBQVMsZ0NBQWdCSix1QkFBaEIsRUFBeUMsQ0FBQ3pELENBQUQsRUFBSUMsQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQXpDLENBQWY7O0FBRUEsTUFBTTZELEtBQUtGLE9BQU8sQ0FBUCxDQUFYO0FBQ0EsTUFBTUcsS0FBS0YsT0FBTyxDQUFQLENBQVg7O0FBRUEsTUFBTUcsSUFBSUYsT0FBT0MsRUFBUCxHQUFZLENBQVosR0FBZ0IsQ0FBQyxDQUFDTCxXQUFXLENBQVosSUFBaUJJLEVBQWxCLEtBQXlCQyxLQUFLRCxFQUE5QixDQUExQjtBQUNBLFNBQU8sb0JBQVUsRUFBVixFQUFjRixNQUFkLEVBQXNCQyxNQUF0QixFQUE4QkcsQ0FBOUIsQ0FBUDtBQUNEIiwiZmlsZSI6IndlYi1tZXJjYXRvci11dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8gLSBUSEUgVVRJTElUSUVTIElOIFRISVMgRklMRSBTSE9VTEQgQkUgSU1QT1JURUQgRlJPTSBXRUItTUVSQ0FUT1ItVklFV1BPUlQgTU9EVUxFXG5cbmltcG9ydCB7VmVjdG9yM30gZnJvbSAnbWF0aC5nbCc7XG5pbXBvcnQge2NyZWF0ZU1hdDQsIHRyYW5zZm9ybVZlY3Rvcn0gZnJvbSAnLi9tYXRoLXV0aWxzJztcblxuaW1wb3J0IG1hdDRfcGVyc3BlY3RpdmUgZnJvbSAnZ2wtbWF0NC9wZXJzcGVjdGl2ZSc7XG5pbXBvcnQgbWF0NF9zY2FsZSBmcm9tICdnbC1tYXQ0L3NjYWxlJztcbmltcG9ydCBtYXQ0X3RyYW5zbGF0ZSBmcm9tICdnbC1tYXQ0L3RyYW5zbGF0ZSc7XG5pbXBvcnQgbWF0NF9yb3RhdGVYIGZyb20gJ2dsLW1hdDQvcm90YXRlWCc7XG5pbXBvcnQgbWF0NF9yb3RhdGVaIGZyb20gJ2dsLW1hdDQvcm90YXRlWic7XG5pbXBvcnQgdmVjMl9sZXJwIGZyb20gJ2dsLXZlYzIvbGVycCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG4vLyBBdmVyYWdlIGNpcmN1bWZlcmVuY2UgKDQwMDc1IGttIGVxdWF0b3JpYWwsIDQwMDA3IGttIG1lcmlkaW9uYWwpXG5jb25zdCBFQVJUSF9DSVJDVU1GRVJFTkNFID0gNDAuMDNlNjtcblxuLyoqIFV0aWwgZnVuY3Rpb25zICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21Ub1NjYWxlKHpvb20pIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVUb1pvb20oc2NhbGUpIHtcbiAgcmV0dXJuIE1hdGgubG9nMihzY2FsZSk7XG59XG5cbi8qKlxuICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICogcGVyc3BlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG5nTGF0VG9Xb3JsZChbbG5nLCBsYXRdLCBzY2FsZSkge1xuICBzY2FsZSAqPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBzY2FsZSAqIChQSSAtIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9MbmdMYXQoW3gsIHldLCBzY2FsZSkge1xuICBzY2FsZSAqPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhbWJkYTIgPSAoeCAvIHNjYWxlKSAqICgyICogUEkpIC0gUEk7XG4gIGNvbnN0IHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChQSSAtICh5IC8gc2NhbGUpICogKDIgKiBQSSkpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgZ2l2ZXMgYSAxIG1ldGVyIHBpeGVsIGF0IGEgY2VydGFpbiBsYXRpdHVkZVxuLy8gUz1DKmNvcyh5KS8yXih6KzgpXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0ZXJab29tKHtsYXRpdHVkZX0pIHtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSkpO1xuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIHJldHVybiBzY2FsZVRvWm9vbShFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lKSAtIDg7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpbiBtZXRlcnMgYXJvdW5kIGN1cnJlbnQgbGF0L2xvbiwgYm90aCBmb3JcbiAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAqIEluIG1lcmNhdG9yIHByb2plY3Rpb24gbW9kZSwgdGhlIGRpc3RhbmNlIHNjYWxlcyB2YXJ5IHNpZ25pZmljYW50bHlcbiAqIHdpdGggbGF0aXR1ZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbSwgc2NhbGUsIGhpZ2hQcmVjaXNpb24gPSBmYWxzZX0pIHtcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZyb20gem9vbSBpZiBub3QgcHJvdmlkZWRcbiAgc2NhbGUgPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiB6b29tVG9TY2FsZSh6b29tKTtcblxuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSAmJiBOdW1iZXIuaXNGaW5pdGUobG9uZ2l0dWRlKSAmJiBOdW1iZXIuaXNGaW5pdGUoc2NhbGUpKTtcblxuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKTtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxvbmdpdHVkZSBhcm91bmQgY3VycmVudCBsYXQvbG9uOlxuICAgICBwaXhlbHNQZXJEZWdyZWVYID0gZChsbmdMYXRUb1dvcmxkKFtsbmcsIGxhdF0pWzBdKS9kKGxuZylcbiAgICAgICA9IHNjYWxlICogVElMRV9TSVpFICogREVHUkVFU19UT19SQURJQU5TIC8gKDIgKiBQSSlcbiAgICAgcGl4ZWxzUGVyRGVncmVlWSA9IGQobG5nTGF0VG9Xb3JsZChbbG5nLCBsYXRdKVsxXSkvZChsYXQpXG4gICAgICAgPSAtc2NhbGUgKiBUSUxFX1NJWkUgKiBERUdSRUVTX1RPX1JBRElBTlMgLyBjb3MobGF0ICogREVHUkVFU19UT19SQURJQU5TKSAgLyAoMiAqIFBJKVxuICAgKi9cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWCA9IHdvcmxkU2l6ZSAvIDM2MDtcbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWSA9IHBpeGVsc1BlckRlZ3JlZVggLyBsYXRDb3NpbmU7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIG1ldGVyIGFyb3VuZCBjdXJyZW50IGxhdC9sb246XG4gICAqL1xuICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgLyBsYXRDb3NpbmU7XG5cbiAgcmVzdWx0LnBpeGVsc1Blck1ldGVyID0gW2FsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICByZXN1bHQubWV0ZXJzUGVyUGl4ZWwgPSBbMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlcl07XG5cbiAgcmVzdWx0LnBpeGVsc1BlckRlZ3JlZSA9IFtwaXhlbHNQZXJEZWdyZWVYLCBwaXhlbHNQZXJEZWdyZWVZLCBhbHRQaXhlbHNQZXJNZXRlcl07XG4gIHJlc3VsdC5kZWdyZWVzUGVyUGl4ZWwgPSBbMSAvIHBpeGVsc1BlckRlZ3JlZVgsIDEgLyBwaXhlbHNQZXJEZWdyZWVZLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuXG4gIC8qKlxuICAgKiBUYXlsb3Igc2VyaWVzIDJuZCBvcmRlciBmb3IgMS9sYXRDb3NpbmVcbiAgICAgZicoYSkgKiAoeCAtIGEpXG4gICAgICAgPSBkKDEvY29zKGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUykpL2QobGF0KSAqIGRMYXRcbiAgICAgICA9IERFR1JFRVNfVE9fUkFESUFOUyAqIHRhbihsYXQgKiBERUdSRUVTX1RPX1JBRElBTlMpIC8gY29zKGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUykgKiBkTGF0XG4gICAqL1xuICBpZiAoaGlnaFByZWNpc2lvbikge1xuICAgIGNvbnN0IGxhdENvc2luZTIgPSBERUdSRUVTX1RPX1JBRElBTlMgKiBNYXRoLnRhbihsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUykgLyBsYXRDb3NpbmU7XG4gICAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWTIgPSBwaXhlbHNQZXJEZWdyZWVYICogbGF0Q29zaW5lMiAvIDI7XG4gICAgY29uc3QgYWx0UGl4ZWxzUGVyRGVncmVlMiA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBsYXRDb3NpbmUyO1xuICAgIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyMiA9IGFsdFBpeGVsc1BlckRlZ3JlZTIgLyBwaXhlbHNQZXJEZWdyZWVZICogYWx0UGl4ZWxzUGVyTWV0ZXI7XG5cbiAgICByZXN1bHQucGl4ZWxzUGVyRGVncmVlMiA9IFswLCBwaXhlbHNQZXJEZWdyZWVZMiwgYWx0UGl4ZWxzUGVyRGVncmVlMl07XG4gICAgcmVzdWx0LnBpeGVsc1Blck1ldGVyMiA9IFthbHRQaXhlbHNQZXJNZXRlcjIsIDAsIGFsdFBpeGVsc1Blck1ldGVyMl07XG4gIH1cblxuICAvLyBNYWluIHJlc3VsdHMsIHVzZWQgZm9yIGNvbnZlcnRpbmcgbWV0ZXJzIHRvIGxhdGxuZyBkZWx0YXMgYW5kIHNjYWxpbmcgb2Zmc2V0c1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBtZXJjYXRvciB3b3JsZCBwb3NpdGlvbiAoXCJwaXhlbHNcIiBpbiBnaXZlbiB6b29tIGxldmVsKVxuICogZnJvbSBhIGxuZy9sYXQgYW5kIG1ldGVyT2Zmc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JsZFBvc2l0aW9uKHtcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgem9vbSxcbiAgc2NhbGUsXG4gIG1ldGVyT2Zmc2V0LFxuICBkaXN0YW5jZVNjYWxlcyA9IG51bGxcbn0pIHtcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZyb20gem9vbSBpZiBub3QgcHJvdmlkZWRcbiAgc2NhbGUgPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiB6b29tVG9TY2FsZSh6b29tKTtcblxuICAvLyBNYWtlIGEgY2VudGVyZWQgdmVyc2lvbiBvZiB0aGUgbWF0cml4IGZvciBwcm9qZWN0aW9uIG1vZGVzIHdpdGhvdXQgYW4gb2Zmc2V0XG4gIGNvbnN0IGNlbnRlcjJkID0gbG5nTGF0VG9Xb3JsZChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHNjYWxlKTtcbiAgY29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoY2VudGVyMmRbMF0sIGNlbnRlcjJkWzFdLCAwKTtcblxuICBpZiAobWV0ZXJPZmZzZXQpIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2Ugc2NhbGVzIGlmIGxuZy9sYXQvem9vbSBhcmUgcHJvdmlkZWRcbiAgICBkaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzIHx8IGdldERpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzY2FsZX0pO1xuXG4gICAgY29uc3QgcGl4ZWxQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKG1ldGVyT2Zmc2V0KVxuICAgICAgLy8gQ29udmVydCB0byBwaXhlbHMgaW4gY3VycmVudCB6b29tXG4gICAgICAuc2NhbGUoZGlzdGFuY2VTY2FsZXMucGl4ZWxzUGVyTWV0ZXIpXG4gICAgICAvLyBXZSB3YW50IHBvc2l0aXZlIFkgdG8gcmVwcmVzZW50IGFuIG9mZnNldCB0b3dhcmRzIG5vcnRoLFxuICAgICAgLy8gYnV0IHdlYiBtZXJjYXRvciB3b3JsZCBjb29yZGluYXRlcyBpcyB0b3AtbGVmdFxuICAgICAgLnNjYWxlKFsxLCAtMSwgMV0pO1xuICAgIGNlbnRlci5hZGQocGl4ZWxQb3NpdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2VudGVyO1xufVxuXG4vLyBBVFRSSUJVVElPTjpcbi8vIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGlzIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5cbi8vIFZhcmlhYmxlIGZvdiAoaW4gcmFkaWFucylcbmZ1bmN0aW9uIGdldEZvdih7aGVpZ2h0LCBhbHRpdHVkZX0pIHtcbiAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oKGhlaWdodCAvIDIpIC8gYWx0aXR1ZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BsYW5lcyh7YWx0aXR1ZGUsIHBpdGNofSkge1xuICAvLyBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgcG9pbnQgdG8gdGhlIGNlbnRlciB0b3BcbiAgLy8gaW4gYWx0aXR1ZGUgdW5pdHMgdXNpbmcgbGF3IG9mIHNpbmVzLlxuICBjb25zdCBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSk7XG4gIGNvbnN0IHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPVxuICAgIE1hdGguc2luKGhhbGZGb3YpICogYWx0aXR1ZGUgLyBNYXRoLnNpbihNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGhhbGZGb3YpO1xuXG4gIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgY29uc3QgZmFyWiA9IE1hdGguY29zKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyBhbHRpdHVkZTtcblxuICByZXR1cm4ge2ZhclosIG5lYXJaOiAwLjF9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld01hdHJpeCh7XG4gIC8vIFZpZXdwb3J0IHByb3BzXG4gIGhlaWdodCxcbiAgcGl0Y2gsXG4gIGJlYXJpbmcsXG4gIGFsdGl0dWRlLFxuICAvLyBQcmUtY2FsY3VsYXRlZCBwYXJhbWV0ZXJzXG4gIGNlbnRlciA9IG51bGwsXG4gIC8vIE9wdGlvbnNcbiAgZmxpcFkgPSBmYWxzZVxufSkge1xuXG4gIC8vIFZJRVcgTUFUUklYOiBQUk9KRUNUUyBNRVJDQVRPUiBXT1JMRCBDT09SRElOQVRFU1xuICAvLyBOb3RlIHRoYXQgbWVyY2F0b3Igd29ybGQgY29vcmRpbmF0ZXMgdHlwaWNhbGx5IG5lZWQgdG8gYmUgZmxpcHBlZFxuICAvL1xuICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbiBvcmRlcnMgc2hvdWxkIGJlIHJlYWQgaW4gcmV2ZXJzZVxuICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgLy8gTW92ZSBjYW1lcmEgdG8gYWx0aXR1ZGUgKGFsb25nIHRoZSBwaXRjaCAmIGJlYXJpbmcgZGlyZWN0aW9uKVxuICBtYXQ0X3RyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcblxuICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICBtYXQ0X3NjYWxlKHZtLCB2bSwgWzEsIDEsIDEgLyBoZWlnaHRdKTtcblxuICAvLyBSb3RhdGUgYnkgYmVhcmluZywgYW5kIHRoZW4gYnkgcGl0Y2ggKHdoaWNoIHRpbHRzIHRoZSB2aWV3KVxuICBtYXQ0X3JvdGF0ZVgodm0sIHZtLCAtcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0X3JvdGF0ZVoodm0sIHZtLCBiZWFyaW5nICogREVHUkVFU19UT19SQURJQU5TKTtcblxuICBpZiAoZmxpcFkpIHtcbiAgICBtYXQ0X3NjYWxlKHZtLCB2bSwgWzEsIC0xLCAxXSk7XG4gIH1cblxuICBpZiAoY2VudGVyKSB7XG4gICAgbWF0NF90cmFuc2xhdGUodm0sIHZtLCBuZXcgVmVjdG9yMyhjZW50ZXIpLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIHJldHVybiB2bTtcbn1cblxuLy8gUFJPSkVDVElPTiBNQVRSSVg6IFBST0pFQ1RTIEZST00gQ0FNRVJBIChWSUVXKSBTUEFDRSBUTyBDTElQU1BBQ0Vcbi8vIFRoaXMgaXMgYSBcIk1hcGJveFwiIHByb2plY3Rpb24gbWF0cml4IC0gbWF0Y2hlcyBtYXBib3ggZXhhY3RseSBpZiBmYXJaTXVsdGlwbGllciA9PT0gMVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2plY3Rpb25NYXRyaXgoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYWx0aXR1ZGUsXG4gIGZhclpNdWx0aXBsaWVyID0gMTBcbn0pIHtcbiAgY29uc3Qge25lYXJaLCBmYXJafSA9IGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KTtcbiAgY29uc3QgZm92ID0gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSk7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfcGVyc3BlY3RpdmUoXG4gICAgW10sXG4gICAgZm92LCAgICAgICAgICAgICAgLy8gZm92IGluIHJhZGlhbnNcbiAgICB3aWR0aCAvIGhlaWdodCwgICAvLyBhc3BlY3QgcmF0aW9cbiAgICBuZWFyWiwgICAgICAgICAgICAvLyBuZWFyIHBsYW5lXG4gICAgZmFyWiAqIGZhclpNdWx0aXBsaWVyIC8vIGZhciBwbGFuZVxuICApO1xuXG4gIHJldHVybiBwcm9qZWN0aW9uTWF0cml4O1xufVxuXG4vKipcbiAqIFByb2plY3QgZmxhdCBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gc2NyZWVuLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtIGZsYXQgY29vcmRpbmF0ZSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlXG4gKiBAcGFyYW0ge01hdHJpeDR9IHBpeGVsUHJvamVjdGlvbk1hdHJpeCAtIHByb2plY3Rpb24gbWF0cml4XG4gKiBAcmV0dXJuIHtBcnJheX0gW3gsIHksIGRlcHRoXSBwaXhlbCBjb29yZGluYXRlIG9uIHNjcmVlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9QaXhlbHMoeHl6LCBwaXhlbFByb2plY3Rpb25NYXRyaXgpIHtcbiAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopKTtcblxuICByZXR1cm4gdHJhbnNmb3JtVmVjdG9yKHBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbn1cblxuLyoqXG4gKiBVbnByb2plY3QgcGl4ZWxzIG9uIHNjcmVlbiB0byBmbGF0IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtIHBpeGVsIGNvb3JkaW5hdGUgb24gc2NyZWVuLlxuICogQHBhcmFtIHtNYXRyaXg0fSBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCAtIHVucHJvamVjdGlvbiBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRaIC0gaWYgcGl4ZWwgY29vcmRpbmF0ZSBkb2VzIG5vdCBoYXZlIGEgM3JkIGNvbXBvbmVudCAoZGVwdGgpLFxuICogICAgdGFyZ2V0WiBpcyB1c2VkIGFzIHRoZSBlbGV2YXRpb24gcGxhbmUgdG8gdW5wcm9qZWN0IG9udG9cbiAqIEByZXR1cm4ge0FycmF5fSBbeCwgeSwgWl0gZmxhdCBjb29yZGluYXRlcyBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGl4ZWxzVG9Xb3JsZCh4eXosIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCB0YXJnZXRaID0gMCkge1xuICBjb25zdCBbeCwgeSwgel0gPSB4eXo7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpKTtcblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHopKSB7XG4gICAgLy8gSGFzIGRlcHRoIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvb3JkID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgeiwgMV0pO1xuICAgIHJldHVybiBjb29yZDtcbiAgfVxuXG4gIC8vIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIGNvcnJlY3QgcHJvamVjdGVkIHogdmFsdWUgZm9yIHRoZSBwb2ludCxcbiAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0IGxpbmUgd2l0aCB6PTBcbiAgY29uc3QgY29vcmQwID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMCwgMV0pO1xuICBjb25zdCBjb29yZDEgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCAxLCAxXSk7XG5cbiAgY29uc3QgejAgPSBjb29yZDBbMl07XG4gIGNvbnN0IHoxID0gY29vcmQxWzJdO1xuXG4gIGNvbnN0IHQgPSB6MCA9PT0gejEgPyAwIDogKCh0YXJnZXRaIHx8IDApIC0gejApIC8gKHoxIC0gejApO1xuICByZXR1cm4gdmVjMl9sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG59XG4iXX0=